#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass aghdpl
\begin_preamble
\chapter{Pierwszy dokument}
\label{cha:pierwszyDokument}

W rozdziale tym przedstawiono podstawowe informacje dotyczące struktury prostych plików \LaTeX a. Omówiono również metody kompilacji plików z zastosowaniem programów \emph{latex} oraz \emph{pdflatex}.

%---------------------------------------------------------------------------

\section{Struktura dokumentu}
\label{sec:strukturaDokumentu}

Plik \LaTeX owy jest plikiem tekstowym, który oprócz tekstu zawiera polecenia formatujące ten tekst (analogicznie do języka HTML). Plik składa się z dwóch części:
\begin{enumerate}%[1)]
\item Preambuły -- określającej klasę dokumentu oraz zawierającej m.in. polecenia dołączającej dodatkowe pakiety;

\item Części głównej -- zawierającej zasadniczą treść dokumentu.
\end{enumerate}



\begin{lstlisting}
      % preambuła



\usepackage{times}
\end_preamble
\use_default_options false
\maintain_unincluded_children false
\language polish
\language_package default
\inputencoding iso8859-2
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 12
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry false
\use_package amsmath 0
\use_package amssymb 0
\use_package cancel 1
\use_package esint 0
\use_package mathdots 0
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\index Indeks
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language polish
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Opis rozwiązania
\begin_inset CommandInset label
LatexCommand label
name "cha:rozwiazanie"

\end_inset


\end_layout

\begin_layout Standard
Niniejszy rozdział zawiera charakterystykę rozwiązania stworzonego na potrzeby
 niniejszej pracy, przedstawiono tutaj najważniejsze wykorzystane algorytmy
 oraz omówiono w skrócie użyte technologie.
\end_layout

\begin_layout Section
Wykorzystane algorytmy
\end_layout

\begin_layout Standard
W rozdziale opisano kilka algorytmów użytych podczas implementacji rozwiązania
 stworzonego na potrzeby niniejszej pracy.
\end_layout

\begin_layout Subsection
Algorytmy genetyczne
\end_layout

\begin_layout Standard
Algorytmy genetyczne zaliczają się do grupy algorytmów ewolucyjnych.
 Zostały opracowane przez Johna Hollanda w latach siedemdziesiątych i są
 inspirowane teorią ewolucji Darwina tudzież ewolucją biologiczną 
\begin_inset CommandInset citation
LatexCommand cite
key "10"

\end_inset

.
 Istnieje wiele różnych prac traktujących o wykorzystaniu algorytmów genetycznyc
h, różnych ich odmianach czy modyfikacjach oraz badaniu ich efektywności.
 Przykładem może być praca magisterska zawarta w pozycji 
\begin_inset CommandInset citation
LatexCommand cite
key "10"

\end_inset

 lub trochę starsza pozycja książkowa 
\begin_inset CommandInset citation
LatexCommand cite
key "12"

\end_inset

.
 Opis implementacji algorytmów genetycznych można znaleść w pozycji 
\begin_inset CommandInset citation
LatexCommand cite
key "13"

\end_inset

.
\end_layout

\begin_layout Subsubsection
Pojęcia
\end_layout

\begin_layout Itemize
Gen - cecha mająca wpływ na jakość rozwiązania.
\end_layout

\begin_layout Itemize
Chromosom - indywiduum, osobnik prezentujący jedno z rozwiązań problemu,
 składa się z genów.
\end_layout

\begin_layout Itemize
Populacja - zbiór chromosomów, prezentuje zbiór rozwiązań danego problemu.
\end_layout

\begin_layout Itemize
Migracja - wymiana osobników pomiędzy populacjami.
\end_layout

\begin_layout Itemize
Selekcja - algorytm wyboru osobników pozostałych w danej populacji w następnym
 cyklu.
\end_layout

\begin_layout Itemize
Krzyżowanie - tworzenie osobników potomnych w trakcie trwania ewolucji na
 podstawie innych, wybranych osobników - rodziców.
\end_layout

\begin_layout Itemize
Mutacja - modyfikacja osobnika zawierająca element losowości, mająca na
 celu próbę ekploracji nowych obszarów rozwiązań.
\end_layout

\begin_layout Itemize
Funkcja przystosowania (ang.
 fitness) - zwana też funckją celu, określa jakość danego rozwiązania.
\end_layout

\begin_layout Itemize
Ewaluacja - wyliczenie wartości funkcji fitness dla każdego osobnika populacji
 czyli inaczej ocena jakości znalezionych rozwiązań.
\end_layout

\begin_layout Itemize
Ewolucja - powtarzający się cykl w trakcie którego następuje rozwój populacji
 oraz w skład którego wchodzi m.in.
 ewaluacja, selekcja, krzyżowanie, mutacja oraz migracja.
 
\end_layout

\begin_layout Itemize
Generacja - jeden cykl algorytmu.
\end_layout

\begin_layout Subsubsection
Model wyspowy
\end_layout

\begin_layout Standard
Jest to odmiana algorytmu genetycznego przystosowana do obliczeń równoległych
 oraz rozproszonych.
 Zamiast jednej dużej populacji rozważamy tutaj kilka podpopulacji zwanych
 wyspami.
 Każda wyspa może być traktowana jako osobna populacja, ponieważ ewolucja
 na niej zachodzi w izolacji od pozostałych wysp.
 Co pewien okres populacje znajdujące się na wyspach wymieniają się między
 sobą pewną ilością osobników w procesie migracji.
 Pozwala to przyśpieszyć znajdywanie rozwiązania.
 Istotna jest tutaj topologia połączeń pomiędzy wyspami pozwalająca na wymianę
 osobników, metoda selekcji migrujących osobników, ich wielkość oraz odstęp
 pomiędzy kolejnymi migracjami.
 Badania różnych parametrów tych zjawis można znaleść m.in.
 w pracy 
\begin_inset CommandInset citation
LatexCommand cite
key "10"

\end_inset

.
\end_layout

\begin_layout Subsubsection
Zastosowanie
\end_layout

\begin_layout Standard
Algorytmy ewolucyjne sprawdzają się tam gdzie nie jest dobrze znana przestrzeń
 rozwiązań ale został określony sposób oceny jakości rozwiązania.
 Znajdują one zastosowanie przy rozwiązywaniu problemów NP, np.
 problemu komiwojażera w którym trzeba znaleść najkrótszą drogę łączącą
 wszystkie miasta tak, aby odwiedzić każde miasto conajmniej raz.
 Innymi zastosowaniami mogą być choćby poszukiwania ekstremów funkcji, których
 nie da się obliczyć analitycznie lub przeszukiwanie dużych przestrzeni
 rozwiązań jak np.
 w przypadku problemu grupowania.
 Alborytmy genetyczne są mniej zależne od wstępnej inicjalizacji zadania
 oraz mniej skłonne do znajdywania rozwiązań lokalnych zamiast optymalnych
 
\begin_inset CommandInset citation
LatexCommand cite
key "9,10"

\end_inset

.
 
\end_layout

\begin_layout Subsection
Master/slave
\end_layout

\begin_layout Standard
Master/slave jest modelem komunikacji w którym jedno urządzenie lub proces
 zwane master kontroluje jedno lub więcej urządzeń lub procesów zwanych
 slave lub worker 
\begin_inset CommandInset citation
LatexCommand cite
key "17"

\end_inset

.
\end_layout

\begin_layout Standard
Ten model komunikacji może zostać wykorzystany w następujących przypadkach:
\end_layout

\begin_layout Itemize
gdy chcemy mieć jeden proces, tzw.
 single-point of responsibility, który podejmuje decyzje lub koordynuje
 akcje w celu zachowania spójności w systemie,
\end_layout

\begin_layout Itemize
potrzebujemy zapewnić jeden punkt dostępu do zewnętrznego systemu lub jeden
 punkt wejścia do systemu,
\end_layout

\begin_layout Itemize
istnieje potrzeba stworzenia scentralizowanego serwisu, np.
 zajmującego się routingiem.
\end_layout

\begin_layout Standard
Rozwiązanie to ma niestety również kilka wad, jak na przykład istnieje niebezpie
czeństwo utworzenia tzw.
 wąskiego gardła co może spowodować problemy z wydajnością lub być tzw.
 single-point of failure.
 Jeśli urządzenie/proces posiadające rolę master ulega awarii, powinniśmy
 w jakiś sposób obsłużyć taką sytuację, np.
 poprzez ponowne wystartowanie procesu/urządzenia z rolą master aby zapewnić
 poprawne i niezawodne działanie komunikacji.
 Sytuacje takie mogą wprowadzić pewne opóźnienia w trakcie odzyskiwania
 sprawności systemu 
\begin_inset CommandInset citation
LatexCommand cite
key "14"

\end_inset

.
\end_layout

\begin_layout Section
Użyte technologie
\end_layout

\begin_layout Standard
Podrozdział przedstawia krótką charakterystykę wykorzystanych technologii
 z uwzględnieniem ich kluczowych z punktu widzenia niniejszej pracy funkcjonalno
ści.
\end_layout

\begin_layout Subsection
Scala
\end_layout

\begin_layout Standard
Do stworzenia platformy na potrzeby niniejszej pracy wykorzystano język
 Scala.
 Głównym aspektem przemawiającym na korzyść tego języka jest to, że do jego
 działania wystarczy maszyna wirtualna Javy.
 Jest to język obiektowy podobnie jak Java ale łączy również zalety języków
 funkcyjnych, które w ostatnim czasie stają się coraz bardziej popularne.
 Zamiarem twórców było stworzenie języka eleganckiego oraz zwięzłego syntaktyczn
ie.
 Mimo, że Scala jest językiem dynamicznie typowanym zapewnia tzw.
 type safety 
\begin_inset CommandInset citation
LatexCommand cite
key "42"

\end_inset

.
 Wprowadza również wiele innowacji oraz ciekawych rozwiązań do konstrukcji
 języka jak np.
 case classes, currying, zagnieżdżanie funkcji, DSL, tail recursion, słowo
 kluczowe lazy lub trait, konsktrukcja podobna do interfejsu z języka Java
 ale mogąca posiadać częściową implementację.
 Scala preferuje obiekty immutable.
 Obsługuje również funkcje wyższego rzędu oraz pozwala zwięźle definiować
 funkcje anonimowe, kładzie również duży nacisk na skalowalność.
 Dodatkową zaletą tego języka jest to, iż jest on w pełni kompatybilny z
 językiem Java, co oznacza, że możemy w nim używać bibliotek lub frameworków
 napisanych w Javie bez żadnych dodatkowych deklaracji.
 Ostatecznie program napisany w Scali jest kompilowany do kodu bajtowego
 Javy 
\begin_inset CommandInset citation
LatexCommand cite
key "27,28,30,8"

\end_inset

.
 Według autora niniejszej pracy do wad tego języka można zaliczyć m.in.
 to, że niektóre instrukcje da się wyrazić na wiele różnych sposobów, co
 utrudnia czytelność kodu oraz zwiększa trudność nauki tej technologii.
\end_layout

\begin_layout Subsection
Akka
\end_layout

\begin_layout Standard
Jednym z kluczowych frameworków wykorzystanych w niniejszej pracy jest Akka.
 Akka jest projektem Open Source na licencji Apache 2.
 Posiada wersję przeznaczoną dla języka Java jak również dla języka Scala.
 Projekt Akka mimo stosunkowo niedługiej obecności na rynku jest w pełni
 gotowy do zastosowań produkcyjnych.
 Cechuje się obecnością wielu interesujących z punktu widzenia niniejszej
 pracy rozszerzeń, które zostały opisane w jednym z następnych podrodziałów,
 wyczerpującej dokumentacji oraz dużej i aktywnej społeczności rozwijającej
 ten produkt a także wsparciem komercyjnych firm.
 Akka używa modelu aktorowego aby zwiększyć poziom abstrakcji i oddzielić
 logikę biznesową od niskopoziomowego zarządzania wątkami oraz operacjami
 I/O 
\begin_inset CommandInset citation
LatexCommand cite
key "29,31"

\end_inset

.
\end_layout

\begin_layout Standard
Podstawowym bytem w technologii Akka są aktorzy.
 Aktor zapewnia wysokopoziomową abstrakcję dla lepszej współbieżności oraz
 zrównoleglenia operacji.
 Jest on lekkim, wydajnym oraz sterowanym zdarzeniami procesem, który komunikuje
 się z innymi aktorami za pomocą asynchronicznych wiadomości przechowywanych
 w skrzynkach odbiorczych.
 Aktor enkapsuluje pewien stan i zachowania, które realizują określone zadania.
 Więcej informacji na temat koncepcji aktorów w projekcie Akka można znaleść
 w pozycji 
\begin_inset CommandInset citation
LatexCommand cite
key "31"

\end_inset

.
\end_layout

\begin_layout Standard
Każdy aktor w systemie może być identyfikowany na kilka różnych sposobów.
 Różnicę pomiędzy kilkoma z nich przedstawiono na rysunku 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Relacja-między-kilkoma"

\end_inset

.
 Więcej informacji na ten temat można znaleść w pozycji 
\begin_inset CommandInset citation
LatexCommand cite
key "48"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ActorPath.png
	lyxscale 30
	scale 40

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Relacja między kilkoma pojęciami identyfikującymi aktorów w systemie 
\begin_inset CommandInset citation
LatexCommand cite
key "48"

\end_inset

.
 
\begin_inset CommandInset label
LatexCommand label
name "fig:Relacja-między-kilkoma"

\end_inset

 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Aktorzy działają w obrębie systemu zwanego Actor System opisanego w pozycji
 
\begin_inset CommandInset citation
LatexCommand cite
key "49"

\end_inset

.
 System aktorowy można traktować jako pewną strukturę z zaalokowaną pulą
 wątków, stworzoną w ramach jednej logicznej aplikacji.
 Konfiguracją puli wątków zajmuje się Akka.
 Pewne ustawienia mogą być zmienione w pliku 
\shape italic
application.conf
\shape default
, który jest głównym plikiem konfiguracyjnym systemu aktorowego.
 System aktorowy zarządza dostępnymi zasobami i może mieć uruchomione miliony
 aktorów gdyż instancja każdego z aktorów zajmuje zaledwie okolo 300 bajtów
 pamięci.
\end_layout

\begin_layout Standard
Akka framework dostarcza wszystkich zalet programowania reaktywnego 
\begin_inset CommandInset citation
LatexCommand cite
key "43"

\end_inset

 oraz zapewnia między innymi:
\end_layout

\begin_layout Itemize
współbieżność, dzięki zaadaptowaniu modelu aktorowego, programista może
 zatem skupić się na logice biznesowej zamiast zajmować się problemami współbież
ności,
\end_layout

\begin_layout Itemize
skalowalność, asynchroniczna komunikacja pomiędzy aktorami dobrze skaluje
 się w systemach multiprocesorowych,
\end_layout

\begin_layout Itemize
odporność na błędy, framework Akka zapożyczył podejście z języka Erlang,
 co pozwoliło wykorzystać model 
\shape italic
let it crash 
\shape default

\begin_inset CommandInset citation
LatexCommand cite
key "54"

\end_inset

 zwany też 
\shape italic
fail fast
\shape default
 do zapewnienia sprawnego działania systemu i skrócenia jego niedostępności,
\end_layout

\begin_layout Itemize
architekture sterowaną zdarzeniami,
\end_layout

\begin_layout Itemize
transakcyjność,
\end_layout

\begin_layout Itemize
ujednolicony model programowania dla potrzeb wielowątkowości oraz obliczeń
 rozproszonych,
\end_layout

\begin_layout Itemize
Akka wspiera zarówno API języka Java jak i języka Scala 
\begin_inset CommandInset citation
LatexCommand cite
key "29"

\end_inset

.
\end_layout

\begin_layout Standard
Zastosowania projektu Akka są bardzo szerokie, można je odnaleść chociażby
 w następujących dziedzinach:
\end_layout

\begin_layout Itemize
analiza danych,
\end_layout

\begin_layout Itemize
bankowość inwestycyjna,
\end_layout

\begin_layout Itemize
eCommerce,
\end_layout

\begin_layout Itemize
symulacje,
\end_layout

\begin_layout Itemize
media społecznościowe.
\end_layout

\begin_layout Standard
Systemy w których potrzebujemy uzyskać wysoką przepustowość oraz małe opóźnienia
 są dobrym kandydatem do wykorzystania frameworka Akka 
\begin_inset CommandInset citation
LatexCommand cite
key "31"

\end_inset

.
\end_layout

\begin_layout Subsection
Rozszerzenia Akka
\end_layout

\begin_layout Standard
W poniższym rodziale opisano kilka ciekawych z puntku widzenia niniejszej
 pracy rozszerzeń projektu Akka wykorzystanych w implementancji stworzonego
 rozwiązania.
\end_layout

\begin_layout Subsubsection
Akka Cluster
\end_layout

\begin_layout Standard
Jest to najbardziej istotne rozszerzenie z punktu widzenia niniejszej pracy.
 Została na nim oparta komunikacja pomiędzy urządzeniami działającymi w
 obrębie klastra.
 Zapewnia ono pewien poziom abstrakcji dla protokołu TCP/IP 
\begin_inset CommandInset citation
LatexCommand cite
key "51"

\end_inset

.
\end_layout

\begin_layout Standard
Dostarcza również odporny na awarię oraz zdecentralizowany serwis członkostwa
 (ang.
 membership service) oparty na protokole Gossip 
\begin_inset CommandInset citation
LatexCommand cite
key "33"

\end_inset

 oraz automatycznej detekcji niedziałających węzłów (ang.
 failure detector).
 
\end_layout

\begin_layout Standard
Pojęcia:
\end_layout

\begin_layout Itemize
węzeł (ang.
 node) - logiczny członek klastra, może istnieć wiele węzłów na jednej fizycznej
 maszynie, identyfikowany krotką: nazwa_hosta:port:uid,
\end_layout

\begin_layout Itemize
klaster (ang.
 cluster) - grupa węzłów zarejestrowana w serwisie członkostwa, 
\end_layout

\begin_layout Itemize
lider (ang.
 leader) - węzeł odpowiedzialny za kluczowe akcje pozwalające zachować odpowiedn
i stan klastra w przypadku dołączania nowych lub awarii istniejących węzłów
 
\begin_inset CommandInset citation
LatexCommand cite
key "31"

\end_inset

.
\end_layout

\begin_layout Standard
Lider jest tylko rolą jaką posiada dany węzeł, każdy węzeł może zostać liderem
 oraz każdy węzeł jest w stanie w sposób deterministyczny wyznaczyć lidera.
 Węzły mogą też posiadać inne role, które mogą się przydać np.
 w ograniczeniu zasięgu komunikacji.
 
\end_layout

\begin_layout Standard
Protokół Gossip wspomniany powyżej pozwala rozpropagować stan klastra do
 wszystkich jego węzłów, tak aby każdy węzeł miał takie same informację
 o pozostałych członkach klastra.
 Protokół ten pomaga uzyskać zbieżność stanu klastra we wszystkich jego
 węzłach w skończonym czasie.
 
\end_layout

\begin_layout Standard
Czlonkostwo w klastrze jest rozpoczynane komendą 
\shape italic
join
\shape default
 wysyłaną do jednego z aktywnych członków klastra, gdy każdy węzeł klastra
 otrzyma informację o dołączającym węźle dzięki protokołowi Gossip, taki
 węzeł może zostać uznany za osiągalny.
 Może on jednak utracić ten stan gdy np.
 wystąpią jakieś problemy z siecią.
 Stan nieosiągalny może trwać jedynie określony czas po upływie którego
 jeśli węzeł nie powróci do pełnej sprawności traci on status członka klastra.
 Każdy węzeł poza nazwą hosta oraz portem jest identyfikowany dodatkowo
 unikalnym identyfikatorem, tzw.
 uid, co pozwala na uruchomienie kilku węzłów klastra na jednej fizycznej
 maszynie.
 Jeżeli członek klastra ulegnie awarii lub opuści klaster na własne życzenie
 nie może on ponownie dołączyć do klastra dopóki system aktorowy uruchomiony
 na nim nie zostanie zrestartowany, co pozwoli na wygenerowanie nowego uid.
 Każdy węzeł może zmienić swój stan członkostwa lub może on zostać zmieniony
 automatycznie dzięki automatycznej detekcji niedziałających węzłów.
 Ustawienia detekcji niedziałających węzłów oraz protokołu Gossip są konfigurowa
lne, tzn.
 że można np.
 ustalić czas po którym węzeł zostanie uznany za nieosiągalny.
 Zdarzenia związane ze zmianą stanu węzłów klastra mogą być subskrybowanie
 przez istniejących członków, co ułatwia implementację monitoringu stanu
 klastra.
 Więcej szczegółów na temat idei członkostwa w klastrze oraz dostępnych
 stanów węzłów można znaleść w pozycjach 
\begin_inset CommandInset citation
LatexCommand cite
key "31,56"

\end_inset

.
 
\end_layout

\begin_layout Standard
Kolejną ciekawą opcją w rozszerzeniu Akka Cluster jest wykorzystanie bibliotek
 Sigar 
\begin_inset CommandInset citation
LatexCommand cite
key "57"

\end_inset

 oraz integracja z nimi.
 Pozwalają one na dostęp do informacji systemowych takich jak zużycie CPU,
 wykorzystanie pamięci RAM, stan sieci.
 Mogą zostać wykorzystane do implementacji load balancigu lub monitorowania
 obciążenia urządzeń klastra 
\begin_inset CommandInset citation
LatexCommand cite
key "34,32"

\end_inset

.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Subsubsection
Cluster Singleton
\end_layout

\begin_layout Standard
Cluster Singleton jest rozszerzeniem projektu Akka zapewniającym jedną instancję
 aktora danego typu w obrębie klastra lub w obrębie węzłów z wybraną rolą.
 Zostało ono wykorzystane do zaimplementowania modelu master/slave opisanego
 w poprzednim podrozdziale.
 Rozszerzenie to dostarcza implementacji menedżera, który pozwala zarządzać
 instancjonowaniem aktora-singletona.
 Dostęp do działającej instancji jest możliwy z każdego urządzenia działającego
 w klastrze i odbywa się przez aktora pośrednika, tzw.
 proxy 
\begin_inset CommandInset citation
LatexCommand cite
key "14"

\end_inset

.
\end_layout

\begin_layout Subsubsection
Distributed Publish Subscribe in Cluster
\end_layout

\begin_layout Standard
Kolejne rozszerzenie projektu Akka, które umożliwia komunikację między aktorami
 bez posiadania informacji na których konkretnie urządzeniach poszczególni
 aktorzy są uruchomieni, czyli lokacja aktora jest transparentna z punktu
 widzenia komunikacji.
 Dostarcza ono aktora-mediatora, który zarządza rejestracją innych aktorów
 do konkretnych kanałów komunikacji którymi są zainteresowani.
 Zachowanie to, można porównać z subskrypcją RSS 
\begin_inset CommandInset citation
LatexCommand cite
key "55"

\end_inset

.
 Wiadomość opublikowana w danym kanale powinna zostać dostarczona do wszystkich
 aktorów, którzy zostali w nim uprzednio zarejestrowani.
 Rozszerzenie to pozwala również wysłać wiadomość do jednego lub większej
 ilości aktorów pasujących do określonego wzorca.
 W niniejszej pracy zostało ono wykorzystane do przesyłania wyników zadania
 do klienta oraz do realizacji migracji populacji w implementacji algorytmów
 genetycznych 
\begin_inset CommandInset citation
LatexCommand cite
key "47"

\end_inset

.
\end_layout

\begin_layout Subsubsection
Akka Persistence 
\end_layout

\begin_layout Standard
Rozszerzenie Akka Persistence pozwala na zapisywanie stanu aktorów w bazie
 danych.
 Pozwala to na odtworzenie stanu aplikacji w przypadku awarii i zapewnia
 w pewnym stopniu niezawodność działania systemu 
\begin_inset CommandInset citation
LatexCommand cite
key "46"

\end_inset

.
 Dostępnych jest wiele różnych dodatków dedykowanych dla różnych technologii
 bazodanowych.
 W niniejszej pracy wykorzystano dodatek przeznaczony do pracy z bazą MongoDB
 
\begin_inset CommandInset citation
LatexCommand cite
key "45"

\end_inset

.
\end_layout

\begin_layout Subsection
Raspberry Pi
\end_layout

\begin_layout Standard
Do testów platformy stworzonej na potrzeby niniejszej pracy wykorzystano
 jedno z urządzeń SoC 
\begin_inset CommandInset citation
LatexCommand cite
key "44"

\end_inset

 jakim jest Raspberry Pi model B.
 Jest to urządzenie stworzone przez fundację non-profit oparte na architekturze
 ARM.
\end_layout

\begin_layout Standard
Na rysunku 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Schemat-Raspberry-Pi"

\end_inset

 przedstawiono schemat urządzenia.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ../../../../Dropbox/School/Praca-inz-lyx/rpi.png
	lyxscale 10
	scale 40

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Schemat Raspberry Pi model B [
\begin_inset CommandInset citation
LatexCommand cite
key "26"

\end_inset

].
 
\begin_inset CommandInset label
LatexCommand label
name "fig:Schemat-Raspberry-Pi"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Urządzenie posiada jednostkę CPU oparty o taktowaniu 700MHz oraz 512MB pamięci
 RAM.
 Poza procesorem CPU jest również wyposażone m.in.
 w jednostkę GPU, dwa porty USB, złącze kart SD (na których może być zainstalowa
na dystrybucja Linuxa), złącze Ethernet 100Mb/s oraz złącze MicroUSB wykorzystan
e do zasilania.
 Pełną specyfikację urządzenia można znaleść w pozycji 
\begin_inset CommandInset citation
LatexCommand cite
key "26"

\end_inset

.
\end_layout

\begin_layout Subsection
MongoDB
\end_layout

\begin_layout Standard
MongoDB jest bazą NoSQL opartą na dokumentach typu JSON, co pozwala na elastyczn
ość oraz przejrzystość w przechowywaniu danych.
 Jest to technologia Open Source.
 Jako, że jest to baza NoSQL posiada ona elastyczny schemat danych.
 Wspiera replikację oraz sharding a także map reduce.
 Technologia ta została wykorzystana ze względu na jej łatwe użycie, dobrą
 skalowalność oraz wydajność przy wykorzystaniu stosunkowo niewielkich zasobów
 obliczeniowych 
\begin_inset CommandInset citation
LatexCommand cite
key "41"

\end_inset

.
\end_layout

\begin_layout Standard
Kolejnymi argumentami przemawiającymi na korzysć tej technologii są łatwa
 dostępność dokumentacji oraz integracja z innymi technologiami wykorzystanymi
 w niniejszej pracy.
\end_layout

\begin_layout Subsection
Play Framework i AngularJS
\end_layout

\begin_layout Standard
Technologie Play Framework oraz AngularJS zostały wykorzystane do przygotowania
 aplikacji webowej będącej interfejsem klienta dzięki któremu może sterować
 on działaniem platformy, monitorować ją oraz oglądać wyniki obliczeń.
\end_layout

\begin_layout Standard
Play Framework jest to technologia server-side, działająca zarówno z językiem
 Java jak i Scala.
 Integruje ona komponenty oraz API potrzebne do stworzenia aplikacji webowej
 opartej o wzorzec MVC.
 Bazuje on na lekkiej, bezstanowej architekturze, niskim zużyciu zasobów,
 wysokiej skalowalności oraz programowaniu reaktywnym.
 Do komunikacji wykorzystuje metody protokołu HTTP oraz pozwala na implementację
 serwisów w technologii REST.
 Play zapewnia również wsparcie dla technologii WebSocket wykorzystanej
 w niniejszej pracy oraz łatwą integrację z frameworkiem Akka 
\begin_inset CommandInset citation
LatexCommand cite
key "35,37"

\end_inset

.
\end_layout

\begin_layout Standard
Z kolei AngularJS jest to technologia stworzona z użyciem języka JavaScript,
 ze wsparciem komercyjnych firm takich jak Google.
 Rozszerza możliwości języka HTML oraz CSS a ponadto pozwala tworzyć tzw.
 SPA (ang.
 Single Page Applications).
 W niniejszej pracy wykorzystano ją do prezentowania informacji odebranych
 z aplikacji serwerowej oraz interakcji z użytkownikiem za pomocą przeglądarki
 internetowej 
\begin_inset CommandInset citation
LatexCommand cite
key "36,38"

\end_inset

.
\end_layout

\begin_layout Subsection
Wykorzystane szablony
\end_layout

\begin_layout Standard
Platforma Typesafe w której skład wchodzą technologie wykorzystane w niniejszej
 pracy, takie jak Play Framework, Akka oraz Scala dostarcza bardzo wyczerpującą
 dokumentację wraz z wieloma przykładami oraz szablonami na licencji Public
 Domain.
\end_layout

\begin_layout Standard
Rozwiązanie stworzone na potrzeby niniejszej pracy bazowało początkowo na
 dwóch szablonach, pierwszy zawierał przykład monitoringu urządzeń podłączonych
 do klastra natomiast drugi dystrybucję zadań pomiędzy urządzenia 
\begin_inset CommandInset citation
LatexCommand cite
key "40,39"

\end_inset

.
\end_layout

\begin_layout Section
Platforma
\end_layout

\begin_layout Standard
Niniejszy podrozdział omawia wybrane aspekty stworzonej platformy, takie
 jak architektura, protokoły komunikacji oraz przydzielanie zadań.
\end_layout

\begin_layout Subsection
Architektura
\end_layout

\begin_layout Standard
Węzeł klastra jest to instancja aplikacji niezwiązana z fizycznym urządzeniem.
 Co oznacza, że na jednym urządzeniu może być uruchomionych kilka węzłów,
 czyli kilka aplikacji.
 W skład platformy wchodzą dwie aplikacje nazwane 
\shape italic
frontend
\shape default
 i 
\shape italic
backend
\shape default
.
 Posiadają one różne odpowiedzialności jak i rodzaje uruchomionych na nich
 aktorów o których zostanie wspomniane w kolejnym podrozdziale.
 
\end_layout

\begin_layout Standard
Aplikacja 
\shape italic
frontend
\shape default
 odpowiada za interakcje z użytkownikiem dzięki takim technologiom jak Play
 Framework, AngularJS, WebSocket oraz protokołowi HTTP.
 Komunikuje się ona z aplikacją 
\shape italic
backend
\shape default
 w celu zlecenia wykonania zadania oraz odebrania wyników.
 Posiada ona interfejs webowy.
 Instancja aplikacji jest traktowana jako osobny węzeł klastra.
\end_layout

\begin_layout Standard
Aplikacja 
\shape italic
backend
\shape default
 nie posiada interfejsu użytkownika.
 Zajmuje się realizacją zleconych zadań.
 Instancja tej aplikacji odpowiada jednemu węzłowi klastra.
 W klastrze może być uruchomionych wiele instancji, po jednej na każdym
 urządzeniu lub jeśli urządzenie posiada wystarczająco mocy obliczeniowej
 może posiadać kilka uruchomionych aplikacji.
 Każda uruchomiona aplikacja posiada uruchomionego workera oraz tylko jedna
 z nich posiada również uruchomionego mastera, gdyż w klastrze powinna być
 tylko jedna aktywna instancja mastera.
\end_layout

\begin_layout Standard
Na rysunku 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Podgląd-architektury."

\end_inset

 przedstawiono podgląd architektury, zielonym kolorem zaznaczono aplikację
 
\shape italic
frontend
\shape default
 natomiast niebieskim aplikację 
\shape italic
backend
\shape default
.
 Założono, że każda aplikacja jest uruchomiona na osobnym urządzeniu pracującym
 w klastrze, są dwa urządzenia wykonujące obliczenia oraz jedno urządzenie
 klienckie.
 Na wspomnianym rysunku pokazano także kilka aktorów uruchomionych na wybranych
 urządzeniach.
 Aplikacja kliencka, która dostarcza interfejsu użytkownika może zostać
 uruchomiona na oddzielnym urządzeniu lub na urządzeniu, które posiada już
 uruchomioną aplikację zajmującą się obliczeniami, czyli posiadającą instancję
 workera.
 Wszystkie urządzenia pracują w sieci lokalnej z wykorzystaniem technologii
 Ethernet.
 Użytkownik komunikuje za pomocą protokołu HTTP z urządzeniem klienckim,
 które z kolei przesyła odpowiednie żadania do urządzenia posiadającego
 aktywnego mastera.
 Urządzenie klienckie nie musi posiadać informacji o tym gdzie dokładnie
 jest aktywny master, ponieważ dostęp do mastera odbywa się poprzez proxy.
 Natomiast aplikacja kliencka powinna mieć podany adres IP przynajmniej
 jednego urządzenia pracującego w klastrze.
 Może mieć informację o kilku adresach IP urządzeń pracujących w klastrze,
 co pozwala uniknąć problemów gdy jedno z urządzeń nie odpowiada.
 Najłatwiejszym sposobem podania adresów urządzeń pracujących w klastrze
 jest użycie dodatkowych argumentów podczas uruchamiania aplikacji.
 Szczegóły tych ustawień oraz sposobu uruchamiania aplikacji wchodzących
 w skład przygotowanej platformy zostały opisane w dodatku A załączonym
 do niniejszej pracy.
\end_layout

\begin_layout Standard
Urządzenia wykonujące obliczenia w klastrze komunikują się ze sobą za pomocą
 protokołu TCP/IP, którym zarządza Akka.
 Odkąd aktywny master posiada listę wszystkich zarejestrowanych workerów
 potrafi on w łatwy sposób nawiązywać z nimi kontakt oraz informować ich
 o nadchodzących zadaniach od klienta.
 Z kolei komunikacja w drugą stronę, np.
 gdy worker skończył wykonywać zadanie i chce wysłać zgromadzone wyniki
 odbywa się przez proxy, ponieważ worker nie wie na którym urządzeniu znajduje
 się aktywny master.
 Gdy master otrzyma wyniki zadania od realizującego je workera odsyła je
 do klienta za pomocą rozszerzenia 
\shape italic
Distributed Publish Subscribe in Cluster 
\shape default
opisanego w jednym z poprzednich podrozdzialow.
 Co oznacza, że nie musi posiadać informacji o adresie IP klienta, ponieważ
 publikuje wiadomości w wybranym temacie i otrzymają je tylko zainteresowani
 klienci.
\end_layout

\begin_layout Standard
Na rysunku 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Podgląd-architektury."

\end_inset

 pokazano jedynie kilka najważniejszych aktorów działających na urządzeniach
 będących częścią klastra.
 Zostali oni opisani wraz z pozostałymi, którzy również są aktywni podczas
 działania platformy w następnym podrozdziale.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename architektura.png
	lyxscale 30
	scale 30

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Podgląd architektury.
 
\begin_inset CommandInset label
LatexCommand label
name "fig:Podgląd-architektury."

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Wybrani aktorzy 
\end_layout

\begin_layout Standard
Aplikacja 
\shape italic
backend
\shape default
:
\end_layout

\begin_layout Itemize
ClusterSingletonManager, aktor dostarczony wraz z rozszerzeniem 
\shape italic
Akka Cluster Singleton
\shape default
, który odpowiada za to aby w klastrze była obecna tylko jedna instancja
 mastera.
 Zostaje on uruchomiony na wszystkich węzłach lub na węzłach z konkretną
 rolą.
 Instancjonuje aktora singletona na najstarszym węźle, czyli takim, który
 dołączył do klastra najwcześniej.
 Monitoruje on również stan dostępności węzła na którym uruchomiony jest
 aktor singleton i w przypadku jakiś awarii startuje nową instancję aktora
 singletona na innym węźle.
\end_layout

\begin_layout Itemize
ClusterSingletonProxy, aktor współpracujący z poprzednim opisanym aktorem
 i będący proxy zapewniającym dostęp do aktora singletona czyli mastera.
 Jest on uruchomiony na każdym węźle, który potrzebuje komunikować się z
 masterem i działa jak router przekierowujący wszystkie przychodzące wiadomości
 do aktora singletona.
 Jeśli aktor ten jest niedostępny np.
 ze względu na awarię lub jest w trakcie odzyskiwania sprawności zadaniem
 aktora ClusterSingletonProxy jest przechowywanie wszystkich odebranych
 wiadomości aż do momentu ponownego nawiązania komunikacji.
 
\begin_inset CommandInset citation
LatexCommand cite
key "14"

\end_inset

.
\end_layout

\begin_layout Itemize
DistributedPubSubMediator, aktor ten zostaje uruchomiony na wszystkich węzłach
 klastra lub na węzłach z konkretną rolą.
 Zarządza rejestracją innych aktorów do wybranych kanałów komunikacji oraz
 replikuje tą wiedzę pośród inne instancje pracujące na pozostałych urządzeniach
 klastra tak aby zachować spójność tych danych w obrębie klastra.
 Zajmuje się również wysyłaniem wiadomości z każdego urządzenia klastra
 do zarejestrowanych aktorów pracujących na jakimkolwiek urządzeniu w obrębie
 klastra.
 
\begin_inset CommandInset citation
LatexCommand cite
key "47"

\end_inset

,
\end_layout

\begin_layout Itemize
Master, jest to tzw.
 aktor singleton.
 Oznacza to że w obrębie klastra powinna być aktywna tylko jedna instancja
 tego aktora.
 Jest to zapewnione poprzez aktora ClusterSingletonManager opisanego powyżej.
 Dostęp do mastera uzyskuje się poprzez proxy, czyli aktora ClusterSingletonProx
y z każdego urządzenia pracującego w klastrze.
 Głównymi zadaniami tego aktora są: przydzielanie zadań workerom, zarządzanie
 ich rejestracją, odbieranie wyników i przesyłanie ich do klienta, reagowanie
 w sytuacji awarii workera i zapisywanie wyników do bazy.
\end_layout

\begin_layout Itemize
Worker, jest to aktor realizujący zadania otrzymane od mastera po uprzedniej
 rejestracji.
 Każdy worker uruchamia jedną instancję aktora wykonującego właściwe obliczenia,
 po to aby zachować responsywność w komunikacji z masterem.
 Zajmuje się on również procesem migracji gdzie znowu jest wykorzystywany
 mechanizm dostarczony wraz z rozszerzeniem 
\shape italic
Distributed Publish Subscribe.
\end_layout

\begin_layout Itemize
WorkExecutor, aktor wykonujący właściwe obliczenia czyli realizujący zadanie
 zlecone przez klienta.
 Jest on instancjonowany przez workera i komunikuje się tylko z nim.
 
\end_layout

\begin_layout Standard
Aplikacja 
\shape italic
frontend
\shape default
:
\end_layout

\begin_layout Itemize
Frontend, aktor z którym komunikuje się użytkownik.
 Odbiera on wyniki zadania od mastera oraz przesyła mu zadania do wykonania.
 Do komunikacji z masterem używa proxy, natomiast wyniki odbiera dzięki
 rozszerzeniu 
\shape italic
Distributed Publish Subscribe
\shape default
 oraz rejestracji w wybranym kanale komunikacji.
\end_layout

\begin_layout Itemize
Metrics, aktor subskrybujący zdarzenia związane ze zmianą różnych metryk
 klastra, np.
 obciążenia CPU lub pamięci RAM.
 Dzięki połączeniu WebSocket przesyła te informację na widok.
\end_layout

\begin_layout Itemize
Monitor, aktory obserwujący zdarzenia związane z członkostwem w klastrze.
 Jeśli jakiś węzeł dołącza do klastra lub go opuszcza taka informacja jest
 aktualizowana na widoku.
\end_layout

\begin_layout Standard
Poza wyżej wymienionymi aktorami działającymi w aplikacji frontend, posiada
 ona również kilka tych samych aktorów co aplikacja frontend, m.in.
 ClusterSingletonProxy oraz DistributedPubSubMediator, którzy służą do komunikac
ji z masterem oraz odbieraniem wyników realizowanych zadań.
\end_layout

\begin_layout Subsection
Protokoły komunikacji
\end_layout

\begin_layout Standard
Na rysunkach 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Rejestracja-Workerów."

\end_inset

 oraz 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Protokół-Master/Worker."

\end_inset

 przedstawiono dwa najważniejsze protokoły definiujące kolejność oraz znaczenie
 poszczególnych wiadomości i służące do komunikacji na linii Frontend -
 Master - Worker - WorkExecutor.
 Widoczni są tam aktorzy biorący lub nie udział w komunikacji oraz rodzaje
 wiadomości przesyłanych między nimi.
\end_layout

\begin_layout Standard
Na rysunku 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Rejestracja-Workerów."

\end_inset

 przedstawiono proces rejestracji workerów w serwisie mastera, po to aby
 master mógł ich poinformować o tym, że posiada jakieś zadanie, które trzeba
 zrealizować.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename registration.png
	lyxscale 60
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Rejestracja Workerów.
 
\begin_inset CommandInset label
LatexCommand label
name "fig:Rejestracja-Workerów."

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
W tabeli 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Opis-komunikatów--"

\end_inset

 przedstawiono opis komunikatów zawartych na rysunku 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Rejestracja-Workerów."

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Opis komunikatów - rejestracja workerów.
 
\begin_inset CommandInset label
LatexCommand label
name "tab:Opis-komunikatów--"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="middle" width="12cm">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Nazwa komunikatu
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Opis
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
RegisterWorker
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Komunikat rejestrujący worker o danym id w serwisie mastera.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
WorkIsReady
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Informacja o tym, że master posiada zakolejkowane zadanie po które dany
 worker może się zgłosić.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Na rysunku 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Protokół-Master/Worker."

\end_inset

 pokazano przepływ informacji podczas zlecenia oraz realizacji zadania.
 Dla uproszczenia przedstawiono przypadek zadania zrealizowanego bez przesyłania
 częściowych wyników.
 W przypadku zadań trwających długo lub gdzie czas trwania nie jest z góry
 określony tzw.
 
\shape italic
long-running jobs
\shape default
 wprowadzono również komunikat 
\shape italic
WorkInProgress
\shape default
, który jest przesyłany cyklicznie w trakcie wykonywania zadania i zawiera
 jego częściowe wyniki, czyli pomiędzy komunikatami 
\shape italic
Work
\shape default
 a 
\shape italic
WorkIsDone
\shape default
.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename work_protocol.png
	lyxscale 60
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Protokół Master/Worker.
 
\begin_inset CommandInset label
LatexCommand label
name "fig:Protokół-Master/Worker."

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
W tabeli 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Opis-komunikatów-w"

\end_inset

 przedstawiono opis komunikatów przesyłanych w trakcie procesu realizacji
 zadań.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Opis komunikatów w trakcie realizacji zadania.
 
\begin_inset CommandInset label
LatexCommand label
name "tab:Opis-komunikatów-w"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="2">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top" width="12cm">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Nazwa komunikatu
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Opis
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Work
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Komunikat przechowujący parametry konfiguracyjne zadania jak również jego
 id.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Ack
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Potwierdzenie odebrania poprzedniego komunikatu.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
WorkIsReady
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Informacja o tym, że master posiada zakolejkowane zadanie po które dany
 worker może się zgłosić.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
WorkerRequestsWork
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Komunikat przechowujący id workera i informujący mastera, że dany worker
 jest wolny i może zająć się kolejnym zadaniem.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
WorkIsProgress
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Komunikat przechowujący częściowe wyniki zadania jak również jego id oraz
 id workera.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
WorkIsDone
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Komunikat przechowujący końcowe wyniki zadania jak i jego id oraz id workera.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Do odpowiedniego rozłożenia obciążenia pomiędzy pracujących workerów początkowo
 rozważano podejście gdzie to master decyduje, któremu workerowi przydzielić
 zadanie bazując między innymi na metrykach takich jak obciążenie CPU lub
 zajętość pamięci RAM.
 Jednak okazało się ono nieefektywne w implementacji testowanych algorytmów
 genetycznych, ponieważ te metryki zmieniały zazwyczaj z opóźnieniem pozostawiaj
ąc workera w stanie bezczynności.
 Zdecydowano się zaimplementować podejście zwane
\shape italic
 Work Pulling Pattern
\shape default
 
\begin_inset CommandInset citation
LatexCommand cite
key "50"

\end_inset

 gdzie to wolny worker zgłasza się po zadanie a nie oczekuje na reakcję
 mastera.
\end_layout

\end_body
\end_document
