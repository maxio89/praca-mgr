#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass aghdpl
\begin_preamble
\chapter{Pierwszy dokument}
\label{cha:pierwszyDokument}

W rozdziale tym przedstawiono podstawowe informacje dotyczące struktury prostych plików \LaTeX a. Omówiono również metody kompilacji plików z zastosowaniem programów \emph{latex} oraz \emph{pdflatex}.

%---------------------------------------------------------------------------

\section{Struktura dokumentu}
\label{sec:strukturaDokumentu}

Plik \LaTeX owy jest plikiem tekstowym, który oprócz tekstu zawiera polecenia formatujące ten tekst (analogicznie do języka HTML). Plik składa się z dwóch części:
\begin{enumerate}%[1)]
\item Preambuły -- określającej klasę dokumentu oraz zawierającej m.in. polecenia dołączającej dodatkowe pakiety;

\item Części głównej -- zawierającej zasadniczą treść dokumentu.
\end{enumerate}



\begin{lstlisting}
      % preambuła



\usepackage{times}
\end_preamble
\use_default_options false
\maintain_unincluded_children false
\language polish
\language_package default
\inputencoding iso8859-2
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 12
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry false
\use_package amsmath 0
\use_package amssymb 0
\use_package cancel 1
\use_package esint 0
\use_package mathdots 0
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\index Indeks
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language polish
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Opis rozwiązania
\begin_inset CommandInset label
LatexCommand label
name "cha:rozwiazanie"

\end_inset


\end_layout

\begin_layout Standard
Niniejszy rozdział zawiera charakterystykę rozwiązania stworzonego na potrzeby
 niniejszej pracy, przedstawiono tutaj najważniejsze wykorzystane algorytmy
 oraz omówiono w skrócie użyte technologie.
\end_layout

\begin_layout Section
Wykorzystane algorytmy
\end_layout

\begin_layout Standard
W rozdziale opisano kilka algorytmów użytych podczas implementacji rozwiązania
 stworzonego na potrzeby niniejszej pracy.
\end_layout

\begin_layout Subsection
Algorytmy genetyczne
\end_layout

\begin_layout Standard
Algorytmy genetyczne zaliczają się do grupy algorytmów ewolucyjnych.
 Zostały opracowane przez Johna Hollanda w latach siedemdziesiątych i są
 inspirowane teorią ewolucji Darwina tudzież ewolucją biologiczną 
\begin_inset CommandInset citation
LatexCommand cite
key "10"

\end_inset

.
 Istnieje wiele różnych prac traktujących o wykorzystaniu algorytmów genetycznyc
h, różnych ich odmianach czy modyfikacjach oraz badaniu ich efektywności.
 Przykładem może być praca magisterska zawarta w pozycji 
\begin_inset CommandInset citation
LatexCommand cite
key "10"

\end_inset

 lub trochę starsza pozycja książkowa 
\begin_inset CommandInset citation
LatexCommand cite
key "12"

\end_inset

.
 Opis implementacji algorytmów genetycznych można znaleść w pozycji 
\begin_inset CommandInset citation
LatexCommand cite
key "13"

\end_inset

.
\end_layout

\begin_layout Subsubsection
Pojęcia
\end_layout

\begin_layout Itemize
Gen - cecha mająca wpływ na jakość rozwiązania.
\end_layout

\begin_layout Itemize
Chromosom - indywiduum, osobnik prezentujący jedno z rozwiązań problemu,
 składa się z genów.
\end_layout

\begin_layout Itemize
Populacja - zbiór chromosomów, prezentuje zbiór rozwiązań danego problemu.
\end_layout

\begin_layout Itemize
Migracja - wymiana osobników pomiędzy populacjami.
\end_layout

\begin_layout Itemize
Selekcja - algorytm wyboru osobników pozostałych w danej populacji w danym
 cyklu.
\end_layout

\begin_layout Itemize
Krzyżowanie - tworzenie osobników potomnych w trakcie trwania ewolucji na
 podstawie innych, wybranych osobników - rodziców.
\end_layout

\begin_layout Itemize
Mutacja - modyfikacja osobnika zawierająca element losowości, mająca na
 celu próbę ekploracji nowych obszarów rozwiązań.
\end_layout

\begin_layout Itemize
Funkcja przystosowania (ang.
 fitness) - zwana też funckją celu, określa jakość danego rozwiązania.
\end_layout

\begin_layout Itemize
Ewaluacja - wyliczenie wartości funkcji fitness dla każdego osobnika populacji
 czyli inaczej ocena jakości znalezionych rozwiązań.
\end_layout

\begin_layout Itemize
Ewolucja - powtarzający się cykl w trakcie którego następuje rozwój populacji
 oraz w skład którego wchodzi m.in.
 ewaluacja, selekcja, krzyżowanie, mutacja oraz migracja.
 
\end_layout

\begin_layout Itemize
Generacja - jeden cykl algorytmu.
\end_layout

\begin_layout Subsubsection
Model wyspowy
\end_layout

\begin_layout Standard
Jest to odmiana algorytmu genetycznego przystosowana do obliczeń równoległych
 oraz rozproszonych.
 Zamiast jednej dużej populacji rozważamy tutaj kilka podpopulacji zwanych
 wyspami.
 Każda wyspa może być traktowana jako osobna populacja, ponieważ ewolucja
 na niej zachodzi w izolacji od pozostałych wysp.
 Co pewien okres populacje znajdujące się na wyspach wymieniają się między
 sobą pewną ilością osobników w procesie migracji.
 Pozwala to przyśpieszyć znajdywanie rozwiązania.
 Istotna jest tutaj topologia połączeń pomiędzy wyspami pozwalająca na wymianę
 osobników, metoda selekcji migrujących osobników, ich wielkość oraz odstęp
 pomiędzy kolejnymi migracjami.
 Badania różnych parametrów tego zjawiska można znaleść m.in.
 w pracy 
\begin_inset CommandInset citation
LatexCommand cite
key "10"

\end_inset

.
\end_layout

\begin_layout Subsubsection
Zastosowanie
\end_layout

\begin_layout Standard
Algorytmy ewolucyjne sprawdzają się tam gdzie nie jest dobrze znana przestrzeń
 rozwiązań ale został określony sposób oceny jakości rozwiązania.
 Znajdują one zastosowanie przy rozwiązywaniu problemów NP, np.
 problemu komiwojażera w którym trzeba znaleść najkrótszą drogę łączącą
 wszystkie miasta tak, aby odwiedzić każde miasto conajmniej raz.
 Innymi zastosowaniami mogą być choćby poszukiwania ekstremów funkcji, których
 nie da się obliczyć analitycznie lub przeszukiwanie dużych przestrzeni
 rozwiązań jak np.
 w przypadku problemu grupowania.
 Alborytmy genetyczne są mniej zależne od wstępnej inicjalizacji oraz mniej
 skłonne do znajdywania rozwiązań lokalnych zamiast optymalnych 
\begin_inset CommandInset citation
LatexCommand cite
key "9,10"

\end_inset

.
 
\end_layout

\begin_layout Subsection
Master/slave
\end_layout

\begin_layout Standard
Master/slave jest modelem komunikacji w którym jedno urządzenie lub proces
 zwane master kontroluje jedno lub więcej urządzeń lub procesów zwanych
 slave lub worker 
\begin_inset CommandInset citation
LatexCommand cite
key "17"

\end_inset

.
\end_layout

\begin_layout Standard
Ten model komunikacji może zostać wykorzystany w następujących przypadkach:
\end_layout

\begin_layout Itemize
gdy chcemy mieć jeden proces, tzw.
 single-point of responsibility, który podejmuje decyzje lub koordynuje
 akcje w celu zachowania spójności w systemie,
\end_layout

\begin_layout Itemize
potrzebujemy zapewnić jeden punkt dostępu do zewnętrznego systemu lub jeden
 punkt wejścia do systemu,
\end_layout

\begin_layout Itemize
istnieje potrzeba stworzenia scentralizowanego serwisu, np.
 zajmującego się routingiem.
\end_layout

\begin_layout Standard
Rozwiązanie to ma niestety również kilka wad, jak na przykład istnieje niebezpie
czeństwo utworzenia tzw.
 wąskiego gardła co może spowodować problemy z wydajnością lub być tzw.
 single-point of failure.
 Jeśli urządzenie/proces posiadające rolę master ulega awarii, powinniśmy
 w jakiś sposób obsłużyć taką sytuację, np.
 poprzez ponowne wystartowanie procesu/urządzenia z rolą master aby zapewnić
 poprawne i niezawodne działanie komunikacji.
 Sytuacje takie mogą wprowadzić pewne opóźnienia w procesie odzyskiwania
 sprawności systemu 
\begin_inset CommandInset citation
LatexCommand cite
key "14"

\end_inset

.
\end_layout

\begin_layout Section
Użyte technologie
\end_layout

\begin_layout Standard
Podrozdział przedstawia krótką charakterystykę wykorzystanych technologii
 z uwzględnieniem ich kluczowych z punktu widzenia niniejszej pracy funkcjonalno
ści.
\end_layout

\begin_layout Subsection
Scala
\end_layout

\begin_layout Standard
Do stworzenia platformy na potrzeby niniejszej pracy wykorzystano język
 Scala.
 Głównym aspektem przemawiającym na korzyść tego języka jest to, że do jego
 działania wystarczy maszyna wirtualna Javy.
 Jest to język obiektowy podobnie jak Java ale łączy również zalety języków
 funkcyjnych, które w ostatnim czasie stają się coraz bardziej popularne.
 Zamiarem twórców było stworzenie języka eleganckiego oraz zwięzłego syntaktyczn
ie.
 Mimo, że Scala jest językiem dynamicznie typowanym zapewnia tzw.
 type safety 
\begin_inset CommandInset citation
LatexCommand cite
key "42"

\end_inset

.
 Wprowadza również wiele innowacji oraz ciekawych rozwiązań do konstrukcji
 języka jak np.
 case classes, currying, zagnieżdżanie funkcji, DSL, tail recursion, słowo
 kluczowe lazy czy trait, konsktrukcja podobna do interfejsu z języka Java
 ale mogąca posiadać częściową implementację.
 Scala preferuje obiekty immutable.
 Obsługuje również funkcje wyższego rzędu oraz pozwala zwięźle definiować
 funkcje anonimowe, kładzie również duży nacisk na skalowalność.
 Dodatkową zaletą tego języka jest to, iż jest on w pełni kompatybilny z
 językiem Java, co oznacza że możemy w nim używać bibliotek lub frameworków
 napisanych w Javie bez żadnych dodatkowych deklaracji.
 Ostatecznie program napisany w Scali jest kompilowany do kodu bajtowego
 Javy 
\begin_inset CommandInset citation
LatexCommand cite
key "27,28,30,8"

\end_inset

.
 Według autora niniejszej pracy do wad tego języka można zaliczyć m.in.
 to, że niektóre instrukcje da się wyrazić na wiele różnych sposobów, co
 utrudnia czytelność kodu oraz zwiększa trudność nauki tej technologii.
\end_layout

\begin_layout Subsection
Akka
\end_layout

\begin_layout Standard
Jednym z kluczowych frameworków wykorzystanych w niniejszej pracy jest Akka.
 Akka jest projektem Open Source na licencji Apache 2.
 Posiada wersję przeznaczoną dla języka Java jak również dla języka Scala.
 Projekt Akka mimo stosunkowo niedługiej obecności na rynku jest w pełni
 gotowy do zastosowań produkcyjnych.
 Cechuje się obecnością wielu interesujących z punktu widzenia niniejszej
 pracy rozszerzeń, które zostały opisane w jednym z następnych podrodziałów,
 wyczerpującej dokumentacji oraz dużej i aktywnej społeczności rozwijającej
 ten produkt a także wsparciem komercyjnych firm.
 Akka używa modelu aktorowego aby zwiększyć poziom abstrakcji i rozdzielić
 logikę biznesową od niskopoziomowego zarządzania wątkami oraz operacjami
 I/O 
\begin_inset CommandInset citation
LatexCommand cite
key "29,31"

\end_inset

.
\end_layout

\begin_layout Standard
Podstawowym bytem w technologii Akka są aktorzy.
 Aktor zapewnia wysokopoziomową abstrakcję dla lepszej współbieżności oraz
 zrównoleglenia operacji.
 Jest on lekkim, wydajnym, sterowanym zdarzeniami procesem, który komunikuje
 się z innymi aktorami za pomocą asynchronicznych wiadomości przechowywanych
 w skrzynkach odbiorczych.
 Aktor enkapsuluje pewien stan i zachowania, które realizują określone zadania.
 Więcej informacji na temat koncepcji aktorów w projekcie Akka można znaleść
 w pozycji 
\begin_inset CommandInset citation
LatexCommand cite
key "31"

\end_inset

.
\end_layout

\begin_layout Standard
Każdy aktor w systemie może być identyfikowany na kilka różnych sposobów.
 Różnicę między kilkoma z nich przedstawiono na rysunku 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Relacja-między-kilkoma"

\end_inset

.
 Więcej informacji na ten temat można znaleść w pozycji 
\begin_inset CommandInset citation
LatexCommand cite
key "48"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ActorPath.png
	lyxscale 30
	scale 40

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Relacja między kilkoma pojęciami identyfikującymi aktorów w systemie 
\begin_inset CommandInset citation
LatexCommand cite
key "48"

\end_inset

.
 
\begin_inset CommandInset label
LatexCommand label
name "fig:Relacja-między-kilkoma"

\end_inset

 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Aktorzy działają w obrębie systemu zwanego Actor System opisanego w pozycji
 
\begin_inset CommandInset citation
LatexCommand cite
key "49"

\end_inset

.
 System aktorowy można traktować jako pewną strukturę z zaalokowaną pulą
 wątków, stworzoną w ramach jednej logicznej aplikacji.
 Konfiguracją puli wątków zajmuje się Akka.
 Pewne ustawienia mogą być zmienione w pliku 
\shape italic
application.conf
\shape default
, który jest głównym plikiem konfiguracyjnym systemu aktorowego.
 System aktorowy zarządza dostępnymi zasobami i może mieć uruchomione miliony
 aktorów, instancja każdego z aktorów zajmuje okolo 300 bajtów pamięci.
\end_layout

\begin_layout Standard
Akka framework dostarcza wszystkich zalet programowania reaktywnego 
\begin_inset CommandInset citation
LatexCommand cite
key "43"

\end_inset

 oraz zapewnia między innymi:
\end_layout

\begin_layout Itemize
współbieżność, dzięki zaadaptowaniu modelu aktorowego, programista może
 zatem skupić się na logice biznesowej zamiast zajmować się problemami współbież
ności,
\end_layout

\begin_layout Itemize
skalowalność, asynchroniczna komunikacja pomiędzy aktorami dobrze skaluje
 się w systemach multiprocesorowych,
\end_layout

\begin_layout Itemize
odporność na błędy, framework Akka zapożyczył podejście z języka Erlang,
 co pozwoliło wykorzystać model 
\shape italic
let it crash 
\shape default

\begin_inset CommandInset citation
LatexCommand cite
key "54"

\end_inset

 zwany też 
\shape italic
fail fast
\shape default
 do zapewnienia sprawnego działania systemu i skrócenia jego niedostępności,
\end_layout

\begin_layout Itemize
architekture sterowana zdarzeniami,
\end_layout

\begin_layout Itemize
transakcyjność,
\end_layout

\begin_layout Itemize
ujednolicony model programowania dla potrzeb programowania wielowątkowego
 oraz obliczeń rozproszonych,
\end_layout

\begin_layout Itemize
Akka wspiera zarówno API języka Java jak i języka Scala 
\begin_inset CommandInset citation
LatexCommand cite
key "29"

\end_inset

.
\end_layout

\begin_layout Standard
Zastosowania projektu Akka są bardzo szerokie, można je znaleść chociażby
 w następujących dziedzinach:
\end_layout

\begin_layout Itemize
analiza danych,
\end_layout

\begin_layout Itemize
bankowość inwestycyjna,
\end_layout

\begin_layout Itemize
eCommerce,
\end_layout

\begin_layout Itemize
symulacje,
\end_layout

\begin_layout Itemize
media społecznościowe.
\end_layout

\begin_layout Standard
Systemy w których potrzebujemy uzyskać wysoką przepustowość oraz małe opóźnienia
 są dobrym kandydatem do wykorzystania frameworka Akka 
\begin_inset CommandInset citation
LatexCommand cite
key "31"

\end_inset

.
\end_layout

\begin_layout Subsection
Rozszerzenia Akka
\end_layout

\begin_layout Standard
W poniższym rodziale opisano kilka ciekawych z puntku widzenia niniejszej
 pracy rozszerzeń projektu Akka wykorzystanych w implementancji stworzonego
 rozwiązania.
\end_layout

\begin_layout Subsubsection
Akka Cluster
\end_layout

\begin_layout Standard
Jest to najbardziej istotne rozszerzenie z punktu widzenia niniejszej pracy.
 Została na nim oparta komunikacja pomiędzy urządzeniami działającymi w
 obrębie klastra.
 Zapewnia ono pewien poziom abstrakcji dla protokołu TCP/IP 
\begin_inset CommandInset citation
LatexCommand cite
key "51"

\end_inset

.
\end_layout

\begin_layout Standard
Dostarcza również odporny na awarię oraz zdecentralizowany serwis członkostwa
 (ang.
 membership service) oparty na protokole Gossip 
\begin_inset CommandInset citation
LatexCommand cite
key "33"

\end_inset

 oraz automatycznej detekcji niedziałających węzłów (ang.
 failure detector).
 
\end_layout

\begin_layout Standard
Pojęcia:
\end_layout

\begin_layout Itemize
węzeł (ang.
 node) - logiczny członek klastra, może istnieć wiele węzłów na jednej fizycznej
 maszynie, identyfikowany krotką nazwa_hosta:port:uid,
\end_layout

\begin_layout Itemize
klaster (ang.
 cluster) - grupa węzłów zarejestrowana w serwisie członkostwa, 
\end_layout

\begin_layout Itemize
lider (ang.
 leader) - węzeł odpowiedzialny za kluczowe akcje pozwalające zachować odpowiedn
i stan klastra w przypadku dołączania nowych lub awarii istniejących węzłów
 
\begin_inset CommandInset citation
LatexCommand cite
key "31"

\end_inset

.
\end_layout

\begin_layout Standard
Protokół Gossip wspomniany powyżej pozwala rozpropagować stan klastra do
 wszystkich jego węzłów, tak aby każdy węzeł miał takie same informację
 o pozostałych członkach klastra.
 Protokół ten pomaga uzyskać zbieżność stanu klastra we wszystkich jego
 węzłach w skończonym czasie.
 
\end_layout

\begin_layout Standard
Czlonkostwo w klastrze jest rozpoczynane komendą 
\shape italic
join
\shape default
 wysyłaną do jednego z aktywnych członków klastra, gdy każdy węzeł klastra
 otrzyma informację o dołączającym węźle dzięki protokołowi Gossip, taki
 węzeł może zostać uznany za osiągalny.
 Może on jednak utracić ten stan gdy np.
 wystąpią jakieś problemy z siecią.
 Stan nieosiągalny może trwać jedynie określony czas po czym jeśli węzeł
 nie powróci do pełnej sprawności straci status członka klastra.
 Każdy węzeł poza nazwą hosta oraz portem jest identyfikowany dodatkowo
 unikalnym identyfikatorem, tzw.
 uid, co pozwala na uruchomienie kilku węzłów hosta na jednej maszynie.
 Jeżeli członek klastra ulegnie awarii lub opuści klaster na własne życzenie
 nie może on ponownie dołączyć do klastra dopóki system aktorowy uruchomiony
 na nim nie zostanie zrestartowany, co pozwoli na wygenerowanie nowego uid.
 Każdy węzeł może zmienić swój stan członkostwa lub może on zostać zmieniony
 automatycznie dzięki automatycznej detekcji niedziałających węzłów.
 Ustawienia detekcji niedziałających węzłów oraz protokołu Gossip są konfigurowa
lne, tzn.
 że można np.
 ustalić czas po którym węzeł zostanie uznany za nieosiągalny.
 Więcej szczegółów na temat idei członkostwa w klastrze oraz dostępnych
 stanów węzłów można znaleść w pozycjach 
\begin_inset CommandInset citation
LatexCommand cite
key "31,56"

\end_inset

.
 
\end_layout

\begin_layout Standard
Lider jest to tylko rola jaką posiada dany węzeł, każdy węzeł może zostać
 liderem oraz każdy węzeł jest w stanie w sposób deterministyczny wyznaczyć
 lidera.
 Węzły mogą też posiadać inne role, które mogą się przydać np.
 w ograniczeniu zasięgu komunikacji.
 
\end_layout

\begin_layout Standard
Zdarzenia związane ze zmianą stanu węzłów klastra mogą być subskrybowanie
 przez istniejących członków, co ułatwia implementację monitoringu stanu
 klastra.
\end_layout

\begin_layout Standard
Kolejną ciekawą opcją w rozszerzeniu Akka Cluster jest wykorzystanie bibliotek
 Sigar 
\begin_inset CommandInset citation
LatexCommand cite
key "57"

\end_inset

 oraz integracja z nimi.
 Pozwalają one na dostęp do informacji systemowych takich jak zużycie CPU,
 wykorzystanie pamięci RAM, stan sieci.
 Mogą zostać wykorzystane do implementacji load balancigu
\begin_inset CommandInset citation
LatexCommand cite
key "34,32"

\end_inset

.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Subsubsection
Cluster Singleton
\end_layout

\begin_layout Standard
Cluster Singleton jest rozszerzeniem projektu Akka zapewniającym jedną instancję
 aktora danego typu w obrębie klastra lub w obrębie węzłów z wybraną rolą.
 Zostało ono wykorzystane do zaimplementowania modelu master/slave opisanego
 w poprzednim podrozdziale.
 Rozszerzenie to dostarcza implementacji menedżera, który pozwala zarządzać
 instancjonowaniem aktora-singletona.
 Dostęp do działającej instancji jest możliwy z każdego urządzenia działającego
 w klastrze i odbywa się przez aktora pośrednika, tzw.
 proxy 
\begin_inset CommandInset citation
LatexCommand cite
key "14"

\end_inset

.
\end_layout

\begin_layout Subsubsection
Distributed Publish Subscribe in Cluster
\end_layout

\begin_layout Standard
Kolejne rozszerzenie projektu Akka, które umożliwia komunikację między aktorami
 bez posiadania informacji na których konkretnie urządzeniach poszczególni
 aktorzy są uruchomieni, czyli lokacja aktora jest transparentna z punktu
 widzenia komunikacji.
 Dostarcza ono aktora-mediatora, który zarządza rejestracją innych aktorów
 do konkretnych kanałów komunikacji którymi są zainteresowani.
 Zachowanie to, można porównać z subskrypcją RSS 
\begin_inset CommandInset citation
LatexCommand cite
key "55"

\end_inset

.
 Wiadomość opublikowana w danym kanale powinna zostać dostarczona do wszystkich
 aktorów, którzy zostali w nim uprzednio zarejestrowani.
 Rozszerzenie to pozwala również wysłać wiadomość do jednego lub większej
 ilości aktorów pasujących do określonego wzorca.
 W niniejszej pracy zostało ono wykorzystane do przesyłania wyników zadania
 do klienta oraz do realizacji migracji populacji w implementacji algorytmów
 genetycznych 
\begin_inset CommandInset citation
LatexCommand cite
key "47"

\end_inset

.
\end_layout

\begin_layout Subsubsection
Akka Persistence 
\end_layout

\begin_layout Standard
Rozszerzenie Akka Persistence pozwala na zapisywanie stanu aktorów w bazie
 danych.
 Pozwala to na odtworzenie stanu aplikacji w przypadku awarii i zapewnia
 w pewnym stopniu niezawodność działania systemu 
\begin_inset CommandInset citation
LatexCommand cite
key "46"

\end_inset

.
 Dostępnych jest wiele różnych dodatków dedykowanych dla różnych technologii
 bazodanowych.
 W niniejszej pracy wykorzystano dodatek przeznaczony do pracy z bazą MongoDB
 
\begin_inset CommandInset citation
LatexCommand cite
key "45"

\end_inset

.
\end_layout

\begin_layout Subsection
Raspberry Pi
\end_layout

\begin_layout Standard
Do testów platformy stworzonej na potrzeby niniejszej pracy wykorzystano
 jedno z urządzeń SoC 
\begin_inset CommandInset citation
LatexCommand cite
key "44"

\end_inset

 jakim jest Raspberry Pi model B.
 Jest to urządzenie stworzone przez fundację non-profit oparte na architekturze
 ARM.
\end_layout

\begin_layout Standard
Na rysunku 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Schemat-Raspberry-Pi"

\end_inset

 przedstawiono schemat urządzenia.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ../../../../Dropbox/School/Praca-inz-lyx/rpi.png
	lyxscale 10
	scale 40

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Schemat Raspberry Pi model B [
\series bold
ODNOSNIK
\series default
].
 
\begin_inset CommandInset label
LatexCommand label
name "fig:Schemat-Raspberry-Pi"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Urządzenie posiada procesor oparty na architekturze ARM o taktowaniu 700MHz
 oraz 512MB pamięci RAM.
 Poza procesorem CPU jest również wyposażone m.in.
 w jednostkę GPU, dwa porty USB, złącze kart SD (na których może być zainstalowa
na dystrybucja Linuxa), złącze Ethernet 100Mb/s oraz złącze MicroUSB wykorzystan
e do zasilania.
 Pełną specyfikację urządzenia można znaleść w pozycji 
\begin_inset CommandInset citation
LatexCommand cite
key "26"

\end_inset

.
\end_layout

\begin_layout Subsection
MongoDB
\end_layout

\begin_layout Standard
MongoDB jest bazą NoSQL opartą na dokumentach typu JSON, co pozwala na elastyczn
ość oraz przejrzystość w przechowywaniu danych.
 Jest to technologia Open Source.
 Jako, że jest to baza NoSQL posiada ona elastyczny schemat danych, wspiera
 replikację oraz sharding a także map reduce.
 Technologia ta została wykorzystana ze względu na jej łatwe użycie, dobrą
 skalowalność oraz wydajność przy wykorzystaniu stosunkowo niewielkich zasobów
 
\begin_inset CommandInset citation
LatexCommand cite
key "41"

\end_inset

.
\end_layout

\begin_layout Standard
Kolejnymi argumentami przemawiającymi na korzysć tej technologii są łatwa
 dostępność dokumentacji oraz integracja z innymi technologiami wykorzystanymi
 w niniejszej pracy.
\end_layout

\begin_layout Subsection
Play Framework i AngularJS
\end_layout

\begin_layout Standard
Technologie Play framework oraz AngularJS zostały wykorzystane do przygotowania
 aplikacji webowej będącej interfejsem klienta dzięki któremu może sterować
 on działaniem platformy, monitorować ją oraz oglądać wyniki obliczeń.
\end_layout

\begin_layout Standard
Play Framework jest to technologia server-side, działająca zarówno z językiem
 Java jak i Scala.
 Integruje ona komponenty oraz API potrzebne do stworzenia aplikacji webowej
 opartej o wzorzec MVC.
 Bazuje on na lekkiej, bezstanowej architekturze, niskim zużyciu zasobów,
 wysokiej skalowalności oraz programowaniu reaktywnym.
 Do komunikacji wykorzystuje metody protokołu HTTP oraz pozwala na implementację
 serwisów w technologii REST.
 Play zapewnia również wsparcie dla technologii WebSocket wykorzystanej
 w niniejszej pracy oraz łatwą integrację z frameworkiem Akka 
\begin_inset CommandInset citation
LatexCommand cite
key "35,37"

\end_inset

.
\end_layout

\begin_layout Standard
Z kolei AngularJS jest to technologia stworzona z użyciem języka JavaScript,
 ze wsparciem komercyjnych firm takich jak Google.
 Rozszerza możliwości języka HTML oraz CSS a ponadto pozwala tworzyć tzw.
 SPA (ang.
 Single Page Applications).
 W niniejszej pracy wykorzystano ją do prezentowania informacji odebranych
 z aplikacji serwerowej oraz interakcji z użytkownikiem za pomocą przeglądarki
 internetowej 
\begin_inset CommandInset citation
LatexCommand cite
key "36,38"

\end_inset

.
\end_layout

\begin_layout Subsection
Wykorzystane szablony
\end_layout

\begin_layout Standard
Platforma Typesafe w której skład wchodzą technologie wykorzystane w niniejszej
 pracy, takie jak Play framework, Akka oraz Scala dostarcza bardzo wyczerpującą
 dokumentację wraz z wieloma przykładami oraz szablonami na licencji Public
 Domain.
\end_layout

\begin_layout Standard
Rozwiązanie stworzone na potrzeby niniejszej pracy bazowało początkowo na
 dwóch szablonach, pierwszy zawierał przykład monitoringu urządzeń podłączonych
 do klastra natomiast drugi dystrybucję zadań pomiędzy urządzenia 
\begin_inset CommandInset citation
LatexCommand cite
key "40,39"

\end_inset

.
\end_layout

\begin_layout Section
Platforma
\end_layout

\begin_layout Standard
Niniejszy podrozdział omawia wybrane aspekty stworzonej platformy, takie
 jak architektura, protokoły komunikacji oraz przydzielanie zadań.
\end_layout

\begin_layout Subsection
Architektura
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename architektura.png
	lyxscale 30
	scale 30

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Podgląd architektury.
 
\begin_inset CommandInset label
LatexCommand label
name "fig:Podgląd-architektury."

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Wybrani aktorzy 
\end_layout

\begin_layout Itemize
ClusterSingletonManager,
\end_layout

\begin_layout Itemize
ClusterSingletonProxy 
\begin_inset CommandInset citation
LatexCommand cite
key "14"

\end_inset

,
\end_layout

\begin_layout Itemize
DistributedPubSubMediator 
\begin_inset CommandInset citation
LatexCommand cite
key "47"

\end_inset

,
\end_layout

\begin_layout Itemize
Master,
\end_layout

\begin_layout Itemize
Worker,
\end_layout

\begin_layout Itemize
WorkExecutor,
\end_layout

\begin_layout Itemize
Frontend,
\end_layout

\begin_layout Itemize
Metrics,
\end_layout

\begin_layout Itemize
Monitor.
\end_layout

\begin_layout Subsection
Komunikacja
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename registration.png
	lyxscale 60
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Rejestracja Workerów.
 
\begin_inset CommandInset label
LatexCommand label
name "fig:Rejestracja-Workerów."

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename work_protocol.png
	lyxscale 60
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Protokół Master/Worker.
 
\begin_inset CommandInset label
LatexCommand label
name "fig:Protokół-Master/Worker."

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Work Pulling Pattern 
\begin_inset CommandInset citation
LatexCommand cite
key "50"

\end_inset


\end_layout

\end_body
\end_document
