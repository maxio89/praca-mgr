#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass aghdpl
\begin_preamble
\chapter{Pierwszy dokument}
\label{cha:pierwszyDokument}

W rozdziale tym przedstawiono podstawowe informacje dotyczące struktury prostych plików \LaTeX a. Omówiono również metody kompilacji plików z zastosowaniem programów \emph{latex} oraz \emph{pdflatex}.

%---------------------------------------------------------------------------

\section{Struktura dokumentu}
\label{sec:strukturaDokumentu}

Plik \LaTeX owy jest plikiem tekstowym, który oprócz tekstu zawiera polecenia formatujące ten tekst (analogicznie do języka HTML). Plik składa się z dwóch części:
\begin{enumerate}%[1)]
\item Preambuły -- określającej klasę dokumentu oraz zawierającej m.in. polecenia dołączającej dodatkowe pakiety;

\item Części głównej -- zawierającej zasadniczą treść dokumentu.
\end{enumerate}



\begin{lstlisting}
      % preambuła



\usepackage{times}
\end_preamble
\use_default_options false
\maintain_unincluded_children false
\language polish
\language_package default
\inputencoding iso8859-2
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 12
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry false
\use_package amsmath 0
\use_package amssymb 0
\use_package cancel 1
\use_package esint 0
\use_package mathdots 0
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\index Indeks
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language polish
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Mobilny klaster obliczeniowy
\begin_inset CommandInset label
LatexCommand label
name "cha:klaster"

\end_inset


\end_layout

\begin_layout Standard
Rozdział ten przedstawia opis przygotowanego rozwiązania.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Na poczatku kazdego rozdzialu musi byc klej (na koncu tez powinien).
 I tak na poczatku 4.
 rozdzialu powinien Pan napisac ze idee opisane wczesniej, w szczegolnosci
 SoC, znalazly odzwierciedlenie w glownej czesci Panskiej pracy magisterskiej,
 gdyz podjal sie Pan oprogramowania klastra obliczeniowego na SoC.
 
\end_layout

\end_inset


\end_layout

\begin_layout Section
Koncepcja
\begin_inset Note Note
status open

\begin_layout Plain Layout
Jaki czas powinien byc uzyty w celach pracy oraz koncepcji? Czy koncepcja
 to sa bardziej szczegolowe cele?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Na rysunku 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Wygląd-klastra"

\end_inset

 zaprezentowano początkową koncepcję przedstawiającą sieć lokalną i działający
 w niej klaster obliczeniowy w skład którego wchodzą urządzenia Raspberry
 Pi, gdzie jedno z nich pełni rolę Master natomiast pozostałe pełnią rolę
 Slave.
 W klastrze znajduje się również uruchomiony serwer WWW służący do komunikacji
 z użytkownikiem za pomocą przeglądarki internetowej.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename Cluster Overview.png
	lyxscale 90
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Plan wyglądu klastra 
\begin_inset CommandInset label
LatexCommand label
name "fig:Wygląd-klastra"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Na urządzeniach uruchomione są aplikacje oparte o technologie JVM, które
 komunikują się ze sobą za pomocą protokołu TCP/IP.
\end_layout

\begin_layout Standard

\series bold
\begin_inset Note Note
status open

\begin_layout Plain Layout

\series bold
Opisac na podstawie notatek/pytan/todosow z jakimi problemami sie zmagano.
\end_layout

\begin_layout Plain Layout

\series bold
load-balancing, wybor nowego mastera, wysylanie progresu, persystencja,
 zapewnienie jednej instancji mastera, wykrywanie awarii, reakcje w przypadku
 awarii, jak konfigurowac zadania, Zapisywac stan aktora na kazdym node
 lub do zdalnej bazki czy przesylac dane do jednego node’a i tam zapisywac,
 np.
 we frontend, Gdzie persystowac dane, co potrzebujemy zapisywac, cala populacje
 co kilka ewaluacji (chyba nie po kazdej?) czy moze tylko najlepszego osobnika?
 - po jakiejs ustalonej liczbie ewolucji mozna robic snapshot, czyli zapisac
 populacje do bazki
\end_layout

\begin_layout Plain Layout

\series bold
czemu odpowiada aktor
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Na urządzeniach klastra wykonywane są obliczenia równolegle, które są rozpoczyna
ne przez klienta klastra a następnie dystrybuowane przez węzeł posiadający
 rolę Master pomiędzy pozostałe wezły posiadające rolę Slave, które zajmują
 się właściwymi obliczeniami.
\end_layout

\begin_layout Standard
Powinna istnieć tylko jedna instancja Mastera w obrębie klastra a w przypadku
 awarii urządzenia na którym znajduje się ta instancja powinna zostać uruchomion
a inna na jednym z pozostałych urządzeń, które będzie w stanie odtworzyć
 stan poprzedniej instancji.
 Co wymaga, aby co jakiś określony czas stan Mastera był zapisywany.
 Stan ten jest istotny ze wględu na przechowywane przez niego informacje
 o wynikach zadania, które nie dotarły jeszcze do klienta lub informacje
 o zadaniach rozpoczętych przez klienta ale nie wysłanych jeszcze do żadnego
 Workera.
 Komunikacja na linii Master-Worker powinna być zaimplementowana w taki
 sposób, aby Master nie stanowił tzw.
 „wąskiego gardła” klastra.
 Wyzwaniem będzie rowniez wybór algorytmu losowania nowego Mastera, jak
 również load-balancing zadań, który powinien być zaimplementowany w sposób
 aby obciążenie Workerów było równomierne i powinien on wyeliminować sytuacje
 gdy Worker jest w stanie bezczynności mimo, że istnieje zakolejkowane zadanie.
\end_layout

\begin_layout Standard
Wyniki zadań odsyłane są do Mastera, który następnie wysyła je klientowi.
 W przypadku długo trwających zadań przesyłane są wyniki częściowe co jakiś
 okreslony czas aby poinformować klienta o postępie prac.
\end_layout

\begin_layout Standard
W trakcie trwania obliczeń częściowe wyniki co jakiś określony czas są zapisywan
e w bazie danych, po to aby możliwe było ich odzyskanie w sytuacji awarii
 któregoś urządzenia.
\end_layout

\begin_layout Standard
Interesującą kwestią jest wybór tego jakie dane wymagają persystencji oraz
 jak często powinna się ona odbywać, a także gdzie będzie przechowywany
 magazyn danych.
 Jeżeli podjęta zostanie decyzja, że na urządzeniu, które może ulec potencjalnej
 awarii, to być może będzie wymagana replikacja aby zapewnić bezpieczenstwo
 danych.
\end_layout

\begin_layout Standard
Poza wykonywaniem zadań platforma monitoruje pracę urządzeń, informuje o
 dołączeniu nowych oraz opuszczeniu klastra przez urządzenie – rozrożniane
 są sytuacje gdy urządzenie opuści klaster na własne życzenie albo ulegnie
 awarii, czyli przestanie brać udział w komunikacji z pozostałymi urządzeniami
 i w takim przypadku zostanie uznane za niedostępne oraz usunięte z klastra
 po jakimś określonym czasie.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Model zadania, jego konfiguracja i inicjalizacja.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Platforma 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Nie uzywac tutaj slowa ewolucja
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Niniejszy podrozdział omawia wybrane aspekty przygotowanej platformy, takie
 jak architektura, protokoły komunikacji oraz sposób przydzielania zadań.
\end_layout

\begin_layout Subsection
Architektura
\end_layout

\begin_layout Standard
Na początek warto wyjaśnić kilka pojęć.
\end_layout

\begin_layout Standard
Węzeł klastra jest to instancja aplikacji niezwiązana z fizycznym urządzeniem.
 Co oznacza, że na jednym urządzeniu może zostać uruchomionych kilka węzłów,
 czyli kilka aplikacji.
 W skład platformy wchodzą właściwie dwie aplikacje nazwane 
\shape italic
frontend
\shape default
 oraz 
\shape italic
backend
\shape default
.
 Posiadają one różne odpowiedzialności jak i różne rodzaje uruchomionych
 na nich aktorów, których dokładniejszy opis znajduje się w kolejnym podrozdzial
e.
 
\end_layout

\begin_layout Standard
Aplikacja 
\shape italic
frontend
\shape default
 odpowiada za interakcję z użytkownikiem dzięki takim technologiom jak Play
 Framework, AngularJS, WebSocket oraz protokołowi HTTP.
 Komunikuje się ona z aplikacją 
\shape italic
backend
\shape default
 w celu zlecenia wykonania zadania oraz odebrania wyników.
 Posiada ona interfejs webowy.
 Instancja aplikacji jest traktowana jako osobny węzeł klastra.
\end_layout

\begin_layout Standard
Aplikacja 
\shape italic
backend
\shape default
 nie posiada interfejsu użytkownika.
 Zajmuje się realizacją zleconych zadań.
 Instancja tej aplikacji również odpowiada jednemu węzłowi klastra.
 W klastrze może być uruchomionych wiele takich instancji, po jednej na
 każdym urządzeniu lub jeśli urządzenie posiada wystarczająco dużo mocy
 obliczeniowej może posiadać ich kilka.
 Każda uruchomiona aplikacja posiada uruchomionego Workera oraz tylko jedna
 z nich posiada również uruchomionego Mastera, gdyż w klastrze powinna być
 tylko jedna aktywna instancja mastera.
\end_layout

\begin_layout Standard
Na rysunku 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Podgląd-architektury."

\end_inset

 przedstawiono podgląd architektury, gdzie zielonym kolorem zaznaczono aplikację
 
\shape italic
frontend
\shape default
 natomiast niebieskim aplikację 
\shape italic
backend
\shape default
.
 Założono, że każda aplikacja jest uruchomiona na osobnym urządzeniu pracującym
 w klastrze, są dwa urządzenia wykonujące obliczenia oraz jedno urządzenie
 klienckie.
 Na wspomnianym rysunku pokazano także kilka aktorów uruchomionych na wybranych
 urządzeniach.
 Założono również, że urządzenia pracują w sieci lokalnej z wykorzystaniem
 technologii Ethernet.
 Użytkownik komunikuje się za pomocą protokołu HTTP z urządzeniem klienckim,
 które z kolei przesyła odpowiednie żądania do urządzenia posiadającego
 aktywnego Mastera.
 Urządzenie klienckie nie musi posiadać informacji o tym gdzie dokładnie
 jest aktywny Master, ponieważ dostęp do mastera odbywa się poprzez proxy.
 Natomiast aplikacja kliencka powinna mieć podany adres IP przynajmniej
 jednego urządzenia pracującego w klastrze.
 Może mieć informację o kilku adresach IP urządzeń pracujących w klastrze,
 co pozwala uniknąć problemów gdy jedno z urządzeń nie odpowiada.
 
\end_layout

\begin_layout Standard
Urządzenia wykonujące obliczenia w klastrze komunikują się ze sobą za pomocą
 protokołu TCP/IP, którym zarządza Akka.
 Odkąd aktywny Master posiada listę wszystkich zarejestrowanych Workerów,
 potrafi on w łatwy sposób nawiązywać z nimi kontakt oraz informować ich
 o nadchodzących zadaniach od klienta.
 Z kolei komunikacja w drugą stronę, np.
 gdy Worker skończył wykonywać zadanie i chce wysłać zgromadzone wyniki
 odbywa się poprzez proxy, ponieważ Worker nie wie na którym urządzeniu
 znajduje się aktywny Master.
 Gdy Master otrzyma wyniki zadania od realizującego je Workera odsyła je
 do klienta za pomocą rozszerzenia 
\shape italic
Distributed Publish Subscribe in Cluster 
\shape default
opisanego w jednym z poprzednich rozdzialow.
 Co oznacza, że nie musi posiadać informacji o adresie IP klienta, ponieważ
 opublikowane wyniki trafią tylko do zainteresowanych odbiorców.
\end_layout

\begin_layout Standard
Na rysunku 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Podgląd-architektury."

\end_inset

 pokazano jedynie kilka najważniejszych aktorów działających na urządzeniach
 będących częścią klastra.
 Zostali oni opisani razem z pozostałymi, którzy również są aktywni podczas
 działania platformy w następnym podrozdziale wraz z podziałem na aplikacje
 w których są wykorzystywani.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename architektura.png
	lyxscale 30
	scale 30

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Podgląd architektury.
 
\begin_inset CommandInset label
LatexCommand label
name "fig:Podgląd-architektury."

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Wybrani aktorzy 
\end_layout

\begin_layout Standard
Poniżej wymieniono kilka aktorów działających w klastrze z uwzględnieniem
 tego na jakiej aplikacji wchodzącej w skład przygotowanej platformy są
 oni uruchomieni.
\end_layout

\begin_layout Standard
Aplikacja 
\shape italic
backend
\shape default
:
\end_layout

\begin_layout Itemize
ClusterSingletonManager, aktor dostarczony wraz z rozszerzeniem 
\shape italic
Akka Cluster Singleton
\shape default
, który odpowiada za to, aby w klastrze była aktywna tylko jedna instancja
 Mastera.
 Zostaje on uruchomiony na wszystkich węzłach lub tylko na węzłach z wybraną
 rolą.
 Instancjonuje aktora typu singleton na najstarszym węźle, czyli takim,
 który dołączył do klastra najwcześniej.
 Monitoruje on również stan dostępności węzła na którym uruchomiony jest
 aktor typu Singleton i w przypadku awarii startuje nową instancję Mastera
 na innym węźle klastra.
\end_layout

\begin_layout Itemize
ClusterSingletonProxy, aktor współpracujący z poprzednim opisanym aktorem
 i będący pośrednikiem (ang.
 proxy) zapewniającym dostęp do aktora typu singleton czyli w tym przypadku
 Mastera.
 Jest on uruchomiony na każdym węźle, który potrzebuje komunikować się z
 Masterem i działa jako router przekierowujący wszystkie przychodzące wiadomości
 do aktora typu singleton.
 Jeśli aktor ten jest niedostępny np.
 ze względu na awarię lub jest w trakcie odzyskiwania sprawności, zadaniem
 aktora ClusterSingletonProxy jest przechowywanie wszystkich odebranych
 wiadomości aż do momentu ponownego nawiązania komunikacji 
\begin_inset CommandInset citation
LatexCommand cite
key "14"

\end_inset

.
\end_layout

\begin_layout Itemize
DistributedPubSubMediator, aktor ten zostaje uruchomiony na wszystkich węzłach
 klastra lub tylko na węzłach z wybraną rolą.
 Zarządza rejestracją innych aktorów do wybranych kanałów komunikacji oraz
 replikuje tą wiedzę pośród inne instancje pracujące na pozostałych urządzeniach
 klastra tak, aby zachować spójność tych danych w obrębie klastra.
 Zajmuje się również wysyłaniem wiadomości z każdego urządzenia klastra
 do zarejestrowanych aktorów pracujących na jakimkolwiek urządzeniu w obrębie
 klastra 
\begin_inset CommandInset citation
LatexCommand cite
key "47"

\end_inset

.
\end_layout

\begin_layout Itemize
Master, jest to aktor typu singleton.
 Oznacza to, że w obrębie klastra powinna być aktywna tylko jedna instancja
 tego aktora.
 Jest to zapewnione poprzez aktora ClusterSingletonManager opisanego powyżej.
 Dostęp do Mastera uzyskuje się poprzez proxy, czyli aktora ClusterSingletonProx
y z każdego urządzenia pracującego w klastrze.
 Głównymi zadaniami tego aktora są: przydzielanie zadań Workerom, zarządzanie
 ich rejestracją, odbieranie wyników i przesyłanie ich do klienta, reagowanie
 w sytuacji awarii jednego z Workerów oraz zapisywanie wyników do bazy.
\end_layout

\begin_layout Itemize
Worker, jest to aktor realizujący zadania otrzymane od Mastera po uprzedniej
 rejestracji w serwisie Mastera.
 Każdy Worker uruchamia jedną instancję aktora wykonującego właściwe obliczenia,
 tzw.
 WorkExecutor po to, aby zachować responsywność podczas komunikacji z Masterem.
 Zajmuje się on również procesem migracji, gdzie znowu jest wykorzystywany
 mechanizm publikowania w wybranym kanale dostarczony wraz z rozszerzeniem
 
\shape italic
Distributed Publish Subscribe.
\end_layout

\begin_layout Itemize
WorkExecutor, aktor wykonujący właściwe obliczenia czyli realizujący zadanie
 zlecone przez klienta.
 Jest on instancjonowany przez Workera i komunikuje się tylko z nim.
 
\end_layout

\begin_layout Standard
Aplikacja 
\shape italic
frontend
\shape default
:
\end_layout

\begin_layout Itemize
Frontend, aktor z którym komunikuje się użytkownik.
 Odbiera on wyniki zadań od Mastera oraz przesyła mu zadania do wykonania.
 Do komunikacji z Masterem używa proxy, natomiast wyniki odbiera dzięki
 rozszerzeniu 
\shape italic
Distributed Publish Subscribe
\shape default
 oraz faktem bycia zarejestrowanym w wybranym kanale komunikacji.
\end_layout

\begin_layout Itemize
Metrics, aktor subskrybujący zdarzenia związane ze zmianą różnych metryk
 klastra, np.
 obciążenia CPU lub pamięci RAM.
 Dzięki połączeniu WebSocket przesyła te informacje na widok.
\end_layout

\begin_layout Itemize
Monitor, aktor obserwujący zdarzenia związane z członkostwem w klastrze.
 Jeżeli jakiś węzeł dołącza do klastra lub go opuszcza taka informacja jest
 aktualizowana na widoku w aplikacji klienckiej.
\end_layout

\begin_layout Standard
Poza wyżej wymienionymi aktorami działającymi w aplikacji 
\shape italic
frontend
\shape default
, posiada ona również kilka podobnych aktorów co aplikacja 
\shape italic
backend
\shape default
, m.in.
 ClusterSingletonProxy oraz DistributedPubSubMediator, którzy służą do komunikac
ji z Masterem oraz odbieraniem wyników realizowanych zadań.
\end_layout

\begin_layout Subsection
Protokoły komunikacji
\end_layout

\begin_layout Standard
Na rysunkach 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Rejestracja-Workerów."

\end_inset

 oraz 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Protokół-Master/Worker."

\end_inset

 przedstawiono dwa najważniejsze protokoły definiujące kolejność oraz rodzaje
 przesyłanych wiadomości podczas komunikacji na linii Frontend - Master
 - Worker - WorkExecutor.
 Widoczni są tam również aktorzy biorący lub nie udział we wspomnianej komunikac
ji.
\end_layout

\begin_layout Standard
Na rysunku 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Rejestracja-Workerów."

\end_inset

 przedstawiono proces rejestracji workerów w serwisie Mastera po to, aby
 Master mógł ich poinformować o tym, że posiada jakieś zadanie, które trzeba
 zrealizować.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename registration.png
	lyxscale 60
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Rejestracja Workerów.
 
\begin_inset CommandInset label
LatexCommand label
name "fig:Rejestracja-Workerów."

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
W tabeli 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Opis-komunikatów--"

\end_inset

 przedstawiono opis komunikatów zawartych na rysunku 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Rejestracja-Workerów."

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Opis komunikatów - rejestracja Workerów.
 
\begin_inset CommandInset label
LatexCommand label
name "tab:Opis-komunikatów--"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="middle" width="12cm">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Nazwa komunikatu
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Opis
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
RegisterWorker
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Komunikat rejestrujący Workera o danym ID w serwisie Mastera.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
WorkIsReady
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Informacja o tym, że Master posiada zakolejkowane zadanie po które dany
 Worker może się zgłosić.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Na rysunku 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Protokół-Master/Worker."

\end_inset

 pokazano przepływ informacji podczas zlecania oraz realizacji zadania.
 Dla uproszczenia przedstawiono przypadek zadania zrealizowanego bez przesyłania
 częściowych wyników.
 W przypadku zadań trwających długo lub gdzie czas trwania nie jest z góry
 określony tzw.
 
\shape italic
long-running jobs
\shape default
 wprowadzono również komunikat 
\shape italic
WorkInProgress
\shape default
, który jest przesyłany cyklicznie w trakcie wykonywania zadania i zawiera
 jego częściowe wyniki, można go umiejscowić pomiędzy komunikatami 
\shape italic
Work
\shape default
 a 
\shape italic
WorkIsDone
\shape default
.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename work_protocol.png
	lyxscale 60
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Protokół Master/Worker.
 
\begin_inset CommandInset label
LatexCommand label
name "fig:Protokół-Master/Worker."

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
W tabeli 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Opis-komunikatów-w"

\end_inset

 przedstawiono opis komunikatów przesyłanych w trakcie procesu realizacji
 zadań.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Opis komunikatów przesyłanych w trakcie realizacji zadania.
 
\begin_inset CommandInset label
LatexCommand label
name "tab:Opis-komunikatów-w"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="2">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top" width="12cm">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Nazwa komunikatu
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Opis
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Work
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Komunikat przechowujący parametry konfiguracyjne zadania, jak również jego
 ID.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Ack
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Potwierdzenie odebrania poprzedniego komunikatu.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
WorkIsReady
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Informacja o tym, że Master posiada zakolejkowane zadanie po które dany
 Worker może się zgłosić.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
WorkerRequestsWork
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Komunikat przechowujący ID Workera i informujący Mastera, że dany Worker
 jest wolny i może zająć się kolejnym zadaniem.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
WorkIsProgress
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Komunikat przechowujący częściowe wyniki zadania, jak również jego ID oraz
 ID Workera.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
WorkIsDone
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Komunikat przechowujący WorkResult oraz ID Workera.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
WorkResult
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Komunikat przechowujący końcowe wyniki zadania jak i jego ID.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Do odpowiedniego rozłożenia obciążenia pomiędzy pracujących Workerów początkowo
 rozważano podejście gdzie to Master decyduje, któremu Workerowi przydzielić
 zadanie bazując między innymi na metrykach takich jak obciążenie CPU lub
 zajętość pamięci RAM.
 Jednak okazało się ono nieefektywne, ponieważ te metryki zmieniały się
 zazwyczaj z opóźnieniem pozostawiając Workera w stanie bezczynności przez
 nieokreślony czas.
 Zdecydowano się zatem zaimplementować podejście zwane
\shape italic
 Work Pulling Pattern
\shape default
 
\begin_inset CommandInset citation
LatexCommand cite
key "50"

\end_inset

 w którym to wolny Worker zgłasza się po zadanie a nie oczekuje na akcję
 Mastera.
\end_layout

\begin_layout Subsection
Monitoring
\end_layout

\begin_layout Standard
Na rysunku 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Podgląd-stanu-klastra"

\end_inset

 przedstawiono interfejs klienta prezentujący obecny stan klastra.
 Wylistowano na nim również listę urządzeń pracujących w klastrze, z uwględnieni
em aktywnego Mastera, adresu IP wraz z portami, dostępność urządzenia oraz
 kilka metryk, m.in.
 zużycie CPU oraz pamięci RAM.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename dashboard.jpg
	lyxscale 30
	scale 30

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Podgląd stanu klastra.
 
\begin_inset CommandInset label
LatexCommand label
name "fig:Podgląd-stanu-klastra"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Stan klastra propagowany jest za pomocą protokołu Gossip opisanego w poprzednim
 rozdziale.
 Jeżeli jakieś urządzenie nie odpowiada przez określony czas w wyniku np.
 problemów z siecią, jest ono uznawane jako niedostępne, czyli nie może
 już przyjmować żadnych zadań ale może jeszcze powrócić do pracy w klastrze
 jeżeli odzyska sprawność w ciągu najbliższych kilku sekund.
 Jeżeli nie, w takim przypadku jest ono usuwane z listy urządzeń pracujących
 w klastrze.
 Po usunięciu urządzenia z klastra nie może ono dołączyć ponownie do klastra
 dopóki aplikacja uruchomiona na tym urządzeniu nie zostanie zrestartowana.
 Pozwala to zapobiec sytuacji, gdy w trakcie problemów z siecią, dane urządzenie
 odłączy się na chwilę od klastra aktywując własnego Mastera a następnie
 po powrocie do klastra bedą aktywne dwa Mastery.
 Dzieje się tak dlatego, że w przypadku gdy urządzenie utraci kontakt z
 pozostałymi urządzeniami, nie może ono z pewnością stwierdzić co było przyczyną
 awarii i zakłada, że jest jedynym urządzeniemi w klastrze.
 
\end_layout

\begin_layout Standard
Stan Mastera jest zapisywany w bazie danych, co pozwala na jego odtworzenie
 w przypadku awarii urządzenia z aktywnym Masterem.
 Do bazy danych persystowane są zserializowane zdarzenia zgodnie ze wzorcem
 Event Sourcing opisanym w pozycjach 
\begin_inset CommandInset citation
LatexCommand cite
key "18,19"

\end_inset

.
 Zdarzenia te odzwierciedlają stan przyjętego zadania.
 Listę zdarzeń oraz ich opis przedstawiono w tabeli 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Lista-zdarzeń-sterujących"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Lista zdarzeń sterujących stanem zadania.
\begin_inset CommandInset label
LatexCommand label
name "tab:Lista-zdarzeń-sterujących"

\end_inset


\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
Przeniesc to do rozdzialu z architektura?
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="2">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top" width="12cm">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Nazwa stanu
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\align left
Opis
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
WorkAccepted
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\align left
Stan zadania po przyjęciu go przez Mastera oraz wysłaniu potwierdzenia do
 klienta.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
WorkStarted
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\align left
Stan zadania przekazanego do realizacji dla Workera.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
WorkInProgress
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\align left
Stan zadania w trakcie trwania obliczeń, przechowujący częsciowe wyniki
 zadania.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
WorkCompleted
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\align left
Stan zadania otrzymany po zakończeniu obliczeń, przechowujący końcowe wyniki.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
WorkerFailed
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\align left
Stan zadania zakończonego niepowodzeniem.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
WorkerTimedOut
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\align left
Stan zadania ustawiany jeśli Worker pracujący nad danym zadaniem nie odeśle
 wyników w określonym czasie.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Dla przykładu, jeżeli klient zadał zadanie i zmieniło ono stan na WorkAccepted
 (czyli zostało zaakceptowane ale nie przesłane jeszcze do żadnego Workera)
 a w tym samym czasie nastąpiła jakaś awaria przerywająca pracę Mastera,
 kolejna instancja Mastera zostanie aktywowana na innym urządzeniu i odtworzy
 stan Mastera, który uległ awarii, co oznacza, że klient nie będzie musiał
 ponownie rozpoczynać zadania, lecz jego poprzednio rozpoczęte zadanie zostanie
 przekazane do realizacji do wolnego Workera.
\end_layout

\begin_layout Standard
Diagram prezentujący dopuszczalne zmiany stanów zadania przedstawiono na
 rysunku 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Przejścia-pomiędzy-stanami"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename work states.png
	lyxscale 50
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Przejścia pomiędzy stanami zadania.
 
\begin_inset CommandInset label
LatexCommand label
name "fig:Przejścia-pomiędzy-stanami"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Dystrybucja 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Przeniesc to do rozdzialu z architektura?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Do łatwej dystrybucji platformy pomiędzy różnymi urządzeniami wykorzystano
 dodatek projektu Akka o nazwie Microkernel oraz rozszerzenie Sbt o nazwie
 sbt-native-packager.
\end_layout

\begin_layout Standard
Akka Microkernel oraz sbt-native-packager dostarczają mechanizmu archiwizowania
 dzięki któremu można udostępniać aplikację jako pojedyńczy plik bez potrzeby
 uruchamiania lub instalowania dodatkowych aplikacji, dostarczania zależności
 lub ręcznego tworzenia skryptów startowych.
 Pozwalają również na wystartowanie systemu aktorowego używając klasy z
 metodą statyczną main 
\begin_inset CommandInset citation
LatexCommand cite
key "15,16"

\end_inset

.
 
\end_layout

\begin_layout Standard
Umożliwia to łatwą instalację oraz uruchomienie platformy na różnych urządzeniac
h klastra.
 Do uruchomienia platformy na danym urządzeniu wystarczy aby posiadało ono
 zainstalowany system wraz z wirtualną maszyną Javy oraz archiwum z platformą,
 które po rozpakowaniu pozwala uruchomić aplikację za pomocą jednego skryptu
 wykonywalnego.
 Żadne dodatkowe oprogramowanie nie jest wymagane.
\end_layout

\begin_layout Section
Inne wykorzystane technologie
\end_layout

\begin_layout Subsection*
Akka Persistence 
\end_layout

\begin_layout Standard
Rozszerzenie Akka Persistence pozwala na zapisywanie stanu aktorów w bazie
 danych.
 Pozwala to na odtworzenie stanu aplikacji w przypadku awarii i zapewnia
 w pewnym stopniu niezawodność działania systemu 
\begin_inset CommandInset citation
LatexCommand cite
key "46"

\end_inset

.
 Dostępnych jest wiele różnych dodatków dedykowanych dla różnych technologii
 bazodanowych.
 W niniejszej pracy wykorzystano dodatek przeznaczony do pracy z bazą MongoDB
 
\begin_inset CommandInset citation
LatexCommand cite
key "45"

\end_inset

.
\end_layout

\begin_layout Subsection*
MongoDB
\end_layout

\begin_layout Standard
MongoDB jest bazą NoSQL opartą na dokumentach typu JSON, co pozwala na elastyczn
ość oraz przejrzystość w przechowywaniu danych.
 Jest to technologia Open Source.
 Jako, że jest to baza NoSQL posiada ona elastyczny schemat danych.
 Wspiera replikację oraz sharding, a także map reduce.
 Technologia ta została wykorzystana ze względu na jej łatwe użycie, dobrą
 skalowalność oraz wydajność przy wykorzystaniu stosunkowo niewielkich zasobów
 obliczeniowych 
\begin_inset CommandInset citation
LatexCommand cite
key "41"

\end_inset

.
\end_layout

\begin_layout Standard
Kolejnymi argumentami przemawiającymi na korzysć tej technologii są łatwa
 dostępność dokumentacji oraz integracja z innymi technologiami wykorzystanymi
 w niniejszej pracy.
\end_layout

\begin_layout Subsection*
Play Framework i AngularJS
\end_layout

\begin_layout Standard
Technologie Play Framework oraz AngularJS zostały wykorzystane do przygotowania
 aplikacji internetowej będącej interfejsem klienta dzięki któremu może
 sterować on działaniem platformy, monitorować ją oraz oglądać wyniki obliczeń.
\end_layout

\begin_layout Standard
Play Framework jest to technologia server-side, działająca zarówno z językiem
 Java jak i Scala.
 Integruje ona komponenty oraz API potrzebne do stworzenia aplikacji klienckiej
 opartej o wzorzec MVC.
 Bazuje on na lekkiej, bezstanowej architekturze, niskim zużyciu zasobów,
 wysokiej skalowalności oraz programowaniu reaktywnym.
 Do komunikacji wykorzystuje metody protokołu HTTP oraz pozwala na implementację
 serwisów w technologii REST.
 Play zapewnia również wsparcie dla technologii WebSocket wykorzystanej
 w niniejszej pracy oraz łatwą integrację z frameworkiem Akka 
\begin_inset CommandInset citation
LatexCommand cite
key "35,37"

\end_inset

.
\end_layout

\begin_layout Standard
Z kolei AngularJS jest to technologia stworzona z użyciem języka JavaScript,
 ze wsparciem komercyjnych firm takich jak Google.
 Rozszerza możliwości języka HTML oraz CSS a ponadto pozwala tworzyć tzw.
 SPA (ang.
 Single Page Applications).
 W niniejszej pracy wykorzystano ją do prezentowania informacji odebranych
 z aplikacji serwerowej oraz interakcji z użytkownikiem za pomocą przeglądarki
 internetowej 
\begin_inset CommandInset citation
LatexCommand cite
key "36,38"

\end_inset

.
\end_layout

\begin_layout Subsection*
Wykorzystane szablony
\end_layout

\begin_layout Standard
Platforma Typesafe w której skład wchodzą technologie wykorzystane w niniejszej
 pracy, takie jak Play Framework, Akka oraz Scala dostarcza bardzo wyczerpującą
 dokumentację wraz z wieloma przykładami oraz szablonami na licencji Public
 Domain.
\end_layout

\begin_layout Standard
Rozwiązanie stworzone na potrzeby niniejszej pracy bazowało początkowo na
 dwóch szablonach, pierwszy zawierał przykład monitoringu urządzeń podłączonych
 do klastra natomiast drugi dystrybucję zadań pomiędzy urządzenia 
\begin_inset CommandInset citation
LatexCommand cite
key "40,39"

\end_inset

.
\end_layout

\end_body
\end_document
