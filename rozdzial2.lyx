#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass aghdpl
\begin_preamble
\chapter{Pierwszy dokument}
\label{cha:pierwszyDokument}

W rozdziale tym przedstawiono podstawowe informacje dotyczące struktury prostych plików \LaTeX a. Omówiono również metody kompilacji plików z zastosowaniem programów \emph{latex} oraz \emph{pdflatex}.

%---------------------------------------------------------------------------

\section{Struktura dokumentu}
\label{sec:strukturaDokumentu}

Plik \LaTeX owy jest plikiem tekstowym, który oprócz tekstu zawiera polecenia formatujące ten tekst (analogicznie do języka HTML). Plik składa się z dwóch części:
\begin{enumerate}%[1)]
\item Preambuły -- określającej klasę dokumentu oraz zawierającej m.in. polecenia dołączającej dodatkowe pakiety;

\item Części głównej -- zawierającej zasadniczą treść dokumentu.
\end{enumerate}



\begin{lstlisting}
      % preambuła



\usepackage{times}
\end_preamble
\use_default_options false
\maintain_unincluded_children false
\language polish
\language_package default
\inputencoding iso8859-2
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 12
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry false
\use_package amsmath 0
\use_package amssymb 0
\use_package cancel 1
\use_package esint 0
\use_package mathdots 0
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\index Indeks
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language polish
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Obliczenia równoległe oraz rozproszone
\begin_inset CommandInset label
LatexCommand label
name "cha:obliczenia"

\end_inset


\end_layout

\begin_layout Standard
Rozdział zawiera klasyfikację modelu architektur równoległych a także opis
 kilku wybranych technologii mających zastosowanie przy obliczeniach równoległyc
h oraz rozproszonych.
\end_layout

\begin_layout Section
Model architektur równoleglych Flynna
\end_layout

\begin_layout Standard
W latach 60-tych Michael Flynn sklasyfikował architektury komputerowe w
 czterech kategoriach biorąc pod uwagę ilość intrukcji oraz ilość strumieni
 danych przetwarzanych przez procesory.
 Poniżej opisano je w skrócie oraz pokazano schematy poglądowe.
\end_layout

\begin_layout Subsection*
SISD (ang.
 Single Instruction, Single Data) 
\end_layout

\begin_layout Standard
Jeden strumień danych jest przetwarzany sekwencyjnie przez jedną instrukcję
 w każdym kolejnym cyklu procesora (rysunek 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Schemat-SISD-."

\end_inset

).
 Wyniki wykonania instrukcji są deterministyczne.
 Wykorzystany w komputerach skalarnych oraz typu mainframe.
 Przykład klasycznej architektury von Neumanna.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename SISD.svg
	lyxscale 40
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Schemat SISD 
\begin_inset CommandInset citation
LatexCommand cite
key "60"

\end_inset

.
 
\begin_inset CommandInset label
LatexCommand label
name "fig:Schemat-SISD-."

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
SIMD (ang.
 Single Instruction, Multiple Data) 
\end_layout

\begin_layout Standard
Ta sama instrukcja jest wykonywana równolegle na wielu procesorach używających
 oddzielnych strumieni danych (rysunek 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Schemat-SIMD-."

\end_inset

).
 Każdy procesor posiada swoją pamięć dla danych.
 Uzyskiwane wyniki są deterministyczne a instrukcje wykonywane są sekwencyjnie
 (ang.
 lockstep).
 Model ten dobrze pasuje do danych, które cechują się pewną regularnością,
 co sprawdza się np.
 przy przetwarzaniu obrazów.
 Jako przykład wykorzystania tej architektury można podać komputery wektorowe
 lub współczesne procesory GPU wykorzystywane m.in.
 w kartach graficznych.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename SIMD.svg
	lyxscale 40
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Schemat SIMD 
\begin_inset CommandInset citation
LatexCommand cite
key "60"

\end_inset

.
 
\begin_inset CommandInset label
LatexCommand label
name "fig:Schemat-SIMD-."

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
MISD (ang.
 Multiple Instruction, Single Data) 
\end_layout

\begin_layout Standard
Wiele niezależnych instrukcji przetwarza równolegle ten sam strumień danych
 (rysunek 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Schemat-MISD-."

\end_inset

).
 Model mający słabe zastosowanie komercyjne, mógłby zostać wykorzystany
 w przypadku potrzeby redundancji obliczeń.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename MISD.svg
	lyxscale 40
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Schemat MISD 
\begin_inset CommandInset citation
LatexCommand cite
key "60"

\end_inset

.
 
\begin_inset CommandInset label
LatexCommand label
name "fig:Schemat-MISD-."

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
MIMD (ang.
 Multiple Instruction, Multiple Data) 
\end_layout

\begin_layout Standard
Wiele procesorów wykonuje równolegle instrukcje przetwarzające niezależne
 strumienie danych (rysunek 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Schemat-MIMD-."

\end_inset

).
 Wykonanie może być synchroniczne jak i niesynchroniczne, jak również determinis
tyczne lub nie.
 Podejście bardziej elastyczne niż SIMD a co za tym idzie mające szersze
 zastosowanie.
 Jako przykład można tutaj podać systemy wieloprocesorowe, klastry lub gridy
 
\begin_inset CommandInset citation
LatexCommand cite
key "61"

\end_inset

.
 Większość współczesnych komputerów korzysta z tej architektury.
 Ta architektura może być stworzona z wielu komponentów SIMD.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename MIMD.svg
	lyxscale 40
	scale 60

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Schemat MIMD 
\begin_inset CommandInset citation
LatexCommand cite
key "60"

\end_inset

.
 
\begin_inset CommandInset label
LatexCommand label
name "fig:Schemat-MIMD-."

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
Wyżej wymieniona klasyfikacja jest jedną z najstarszych oraz najbardziej
 ogólnych, będącą zazwyczaj punktem wyjścia do innych, bardziej szczegółowych
 lub biorących pod uwagę inne aspekty zrównoleglania obliczeń.
 W klasycznej pozycji książkowej 
\begin_inset CommandInset citation
LatexCommand cite
key "61"

\end_inset

 rozważono ponadto równoległość na różnych poziomach abstrakcji, takich
 jak instrukcje (Instruction-Level Parallelism), dane (Data-Level Parallelism)
 oraz wątki (Thread-Level Parallelism).
\end_layout

\begin_layout Section
Modele programowania równoległego
\end_layout

\begin_layout Standard
Poniższy rozdzial zawiera wstęp do kilku modeli programowania równoległego
 opartych na architekturze MIMD.
 Modele te istnieją jako abstrakcja od fizycznej architektury sprzętowej,
 co oznacza, że w niektórych przypadkach mogą być zaimplementowane na różnych
 architekturach sprzętowych.
\end_layout

\begin_layout Subsection*
SPMD (ang.
 Single Program, Multiple Data)
\end_layout

\begin_layout Standard
W tym modelu wiele procesorów wykonuje równolegle ten sam program przetwarzając
 różne strumienie danych.
 Jest to najbardziej powszechny model programowania równoległego, który
 może być wykonywany na większości współczesnych procesorach powszechnego
 użytku.
 Zazwyczaj model ten nie wymaga synchronizacji tak jak w SIMD, gdyż procesory
 wykonują różne niezależne części programu i nie muszą się one wykonywać
 w tzw.
 lockstepie 
\begin_inset CommandInset citation
LatexCommand cite
key "62"

\end_inset

 tak jak w przypadku SIMD.
\end_layout

\begin_layout Subsection*
MPMD (ang.
 Multiple Program, Multiple Data)
\end_layout

\begin_layout Standard
Kolejny model programowania równoległego, który może mieć szersze zastosowanie
 aniżeli SPMD.
 Wiele niezależnych procesorów wykonuje równolegle conajmniej dwa niezależne
 programy.
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
Model SPMD implikuje kolejną klasyfikację ze względu na dostęp do pamięci
 biorąc pod uwagę pamięć współdzieloną oraz rozproszoną czyli Shared Memory
 oraz Distributed Memory.
\end_layout

\begin_layout Subsection*
Shared Memory (SM)
\end_layout

\begin_layout Standard
Procesy współdzielą jakiś obszar pamięci przechowujący dane, które odczytują
 lub zapisują asynchronicznie.
 Nie musi tutaj występować komunikacja pomiędzy procesami natomiast potrzebne
 są jakieś mechanizmy kontroli dostępu do danych, takie jak synchronizacja,
 semafory, blokady (ang.
 lock) lub bariery pamięci zapewniające poprawność wykonywania operacji
 przy zachowaniu spójności danych.
 W związku z wymienionymi problemami programy korzystające z pamięci współdzielo
nej mogą być niederministyczne.
\end_layout

\begin_layout Subsection*
Distributed Memory (DM)
\end_layout

\begin_layout Standard
Każdy proces posiada swoją własną przestrzeń pamięci, co oznacza, że nie
 ma bezpośredniego dostępu do pamięci innych procesów.
 Co za tym idzie wymagana jest komunikacja pomiędzy procesami w celu wymiany
 informacji przez co mogą wystąpić jakieś opóźnienia w obliczeniach związane
 z narzutem komunikacji.
 Obszary pamięci nie muszą być podzielone sprzętowo, co oznacza, że ten
 model programowania może być zaimplementowany na sprzęcie posiadającym
 pamięć współdzieloną podzieloną logicznie pomiędzy procesy.
 Problemami, które mogą wystąpić w opisywanym modelu jest load-balancing,
 podzielenie zadania na odpowiednie procesy, jak również łączenie wyników
 zadań po zakończeniu obliczeń.
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
Poniżej wymieniono kilka innych modeli programowania równoległego z uwględnienie
m tego czy korzystają one z pamięci współdzielonej lub nie.
\end_layout

\begin_layout Subsection*
Data Parallel 
\end_layout

\begin_layout Standard
Jest jedna zorganizowana globalna przestrzeń danych, np.
 w postaci tablicy na której operują procesy wykonujące się równolegle.
 Procesy wykonują operacje na swojej wydzielonej części pamięci.
 Operacja może polegać na przykład na dodaniu konkretnej liczby do kilku
 elementów tablicy.
 Jeżeli tablica posiada sto elementów, a dziesięć różnych procesów wykonuje
 na niej jakieś operację, to każdy proces może mieć dostęp do dziesięciu
 elementów tablicy, co oznacza, że żaden proces nie będzie operował na tym
 samym elemencie tablicy.
 Wykorzystuje model SM.
\end_layout

\begin_layout Subsection*
Message Passing 
\end_layout

\begin_layout Standard
W tym modelu procesy, zwane również zadaniami (ang.
 tasks) posiadają dane na których operują.
 Każdy zadanie posiada unikalny identyfikator i komunikuje się z innymi
 zadaniami przesyłając im jakieś informacje.
 Komunikacja musi być zazwyczaj skoordynowana, co oznacza, że po operacji
 wysłania musi nastąpić odbiór wiadomości w innym zadaniu.
 Zadania mogą wykonywać się równolegle, mogą być również tworzone dynamicznie.
 Każde zadanie może wykonywać się na oddzielnym procesorze, może być również
 umieszczony na innej fizycznej maszynie.
 Implementacją tego modelu jest standard MPI, który zostanie opisany później.
 Model ten wykorzystuje DM.
\end_layout

\begin_layout Subsection*
Threads
\end_layout

\begin_layout Standard
W tym modelu jeden złożony proces może posiadać kilka wykonywanych współbieżnie
 ścieżek, tzw.
 wątków.
 Dla przykładu załóżmy, że procesem jest program, który po starcie uruchamia
 kilka zadań wykonywanych równolegle przez różne wątki.
 Wykonywaniem równoległych wątków zajmuje się system operacyjny na którym
 ten program jest uruchomiony.
 Każdy wątek może posiadać swoje lokalne dane, które są prywatne i niewidoczne
 dla innych wątków ale może również współdzielić dane zaalokowane przez
 główny program z innymi wątkami, tzw.
 dane globalne.
 W przypadku gdy wątki potrzebują się ze sobą komunikować, mogą to zrobić
 właśnie przez dane globalne widziane z innych wątków.
 W takim przypadku jeśli chcemy uniknąć sytuacji, że dwa wątki próbują modyfikow
ać ten sam obszar pamięci w tym samym czasie musi nastąpić synchronizacja
 dostępu do niego.
 Wątki mogą być tworzone i usuwane dynamicznie przez główny program i dzięki
 niemu mogą również współdzielić zasoby.
 Wykorzystuje model SM.
 Problemy, które mogą wystąpić w przypadku tego modelu, to zablokowanie
 wątków (ang.
 deadlock), zagłodzenie wątków (ang.
 starvation) oraz tzw.
 race condition 
\begin_inset CommandInset citation
LatexCommand cite
key "68,63,61"

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
W modelu Shared Memory jeżeli procesy operują na wspólnych danych utrudnieniem
 jest kontrola ich dostępu oraz zapewnienie zadowalającej wydajności obliczeń.
 Różne technologie oraz modele programowania równoległego zapewniają rozwiązania
, które czasem mogą okazać się niewystarczające lub źle wpływać na proces
 zrównoleglania.
 W przypadku gdy współdzielony stan (pamięć) jest mutowalny, czyli może
 być modyfikowany przez wiele procesów, rozwiązaniem powinna być synchronizacja
 dostępu.
 Jeżeli jednak każdy proces posiada odizolowany stan, który nie może być
 mutowalny, to synchronizacja jest niepotrzebna lecz tracimy również możliwość
 współdzielenia stanu.
 Jednym z rozwiązań tych problemów jest wykorzystanie podejścia z języków
 funkcyjnych takich jak Scala lub Erlang, czyli niemutowalnych obiektów.
 Modelem wykorzystującym takie obiekty do przesyłania komunikatów jest model
 aktorowy wykorzystany m.in.
 we wspomnianych wyżej językach funkcyjnych oraz w wielu innych do zrównoleglani
a obliczeń.
\end_layout

\begin_layout Subsection*
Model Aktorowy (ang.
 Actor Model)
\end_layout

\begin_layout Standard
W modelu aktorowym głównym bytem są aktorzy.
 Komunikują się oni ze sobą asynchronicznie poprzez wymianę wiadomości a
 więc są trochę podobni do zadań w modelu Message Passing.
 Po wysłaniu wiadomości nie muszą czekać na odpowiedź a kolejność dostarczania
 wiadomości jest nieistotna.
 Wiadomości są buforowane w skrzynkach odbiorczych.
 Każdy aktor przechowuje jakiś stan, który nie powinien być widoczny dla
 innych aktorów i może zostać zmieniony jedynie przez tego samego aktora.
 Model aktorowy wykorzystuje Shared Memory.
 Zaimplementowano go m.in.
 w Erlangu lub Scali.
 Zaletą tego modelu jest to, że nie trzeba się martwić o współdzielenie
 skomplikowanych stanów lecz z drugiej strony problem nie zawsze da się
 podzielić na mniejsze części i zaimplementować z wykorzystaniem aktorów,
 co można traktować jako wadę tego podejścia 
\begin_inset CommandInset citation
LatexCommand cite
key "72"

\end_inset

.
\end_layout

\begin_layout Subsection*
STM (ang.
 Software Transactional Memory)
\end_layout

\begin_layout Standard
Wprowadza pojęcie atomicznych transakcji.
 Każdy dostęp do pamięci wpółdzielonej objęty jest transakcją, której idea
 jest podobna do transakcji bazodanowych.
 Jest to alternatywa do blokowaniu dostępu do pamięci poprzez synchronizację.
 Transakcja obejmuje serię odczytów i zapisów do pamięci współdzielonej
 a jej stan nie jest widoczny dla innych transakcji dopóki nie zostanie
 ona zakończona i zakomitowana.
 Wyróżnia się tutaj sekcje krytyczne zwane blokami atomicznymi.
 Jeżeli wykonanie takiego bloku się nie powiedzie zmiany są wycofywane,
 co wymusza przechowywanie starszej wersji danych.
 Transakcje mogą wykonywać się równolegle.
 Model ten zaimplementowano w wielu popularnych językach programowania,
 m.in.
 w języku Scala 
\begin_inset CommandInset citation
LatexCommand cite
key "69,70"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
W literaturze można znaleść jeszcze wiele innych modeli programowania równoległe
go wykorzystujących podobne koncepcje jak te opisane powyżej, jak również
 wprowadzające zupełnie inne podejścia.
 Ostatnim modelem, który zostanie opisany jest Master/Slave ze względu na
 szersze wykorzystanie go w niniejszej pracy.
\end_layout

\begin_layout Subsection*
Master/Slave 
\end_layout

\begin_layout Standard
Master/Slave może być implementacją modelu SPMD.
 Polega on na tym, że jedno urządzenie lub proces zwane Master kontroluje
 jedno lub więcej urządzeń lub procesów zwanych Slave lub Worker 
\begin_inset CommandInset citation
LatexCommand cite
key "17"

\end_inset

.
 Obliczenia wykonywane przez Workery odbywają się równolegle, natomiast
 Master odpowiada za load-balancing oraz łączenie wyników w jedną całość.
\end_layout

\begin_layout Standard
Może okazać się przydatny w następujących przypadkach:
\end_layout

\begin_layout Itemize
gdy chcemy mieć jeden proces, tzw.
 single-point of responsibility, który podejmuje decyzje lub koordynuje
 akcje w celu zachowania spójności w systemie,
\end_layout

\begin_layout Itemize
potrzebujemy zapewnić jeden punkt dostępu do zewnętrznego systemu lub jeden
 punkt wejścia do systemu z zewnątrz,
\end_layout

\begin_layout Itemize
istnieje potrzeba stworzenia scentralizowanego serwisu, np.
 zajmującego się routingiem,
\end_layout

\begin_layout Itemize
istnieje możliwość podzielenia zadania na kilka części, z których każda
 może być wykonywana równolegle.
\end_layout

\begin_layout Standard
Rozwiązanie to ma niestety również kilka wad, jak na przykład istnieje niebezpie
czeństwo utworzenia tzw.
 wąskiego gardła co może spowodować problemy z wydajnością lub być tzw.
 single-point of failure.
 Jeśli urządzenie/proces posiadające rolę Master ulega awarii, powinniśmy
 w jakiś sposób obsłużyć taką sytuację np.
 poprzez ponowne wystartowanie procesu/urządzenia z rolą Master, aby zapewnić
 poprawne i niezawodne działanie komunikacji.
 Sytuacje takie mogą wprowadzić pewne opóźnienia w trakcie odzyskiwania
 sprawności systemu 
\begin_inset CommandInset citation
LatexCommand cite
key "14"

\end_inset

.
\end_layout

\begin_layout Section
Istniejące rozwiązania
\begin_inset Note Note
status open

\begin_layout Plain Layout
Rozdzialy wymagaja wstepu, np.
 2.3.
 - powinien napisac Pan dwa zdania tak zeby sie kleil tekst - poprzedni
 rozdzial mowil o modelach a tu mowi Pan o implementacjach...
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Dla większości modeli programowania równoległego wymienionych w poprzednim
 rozdziale można znaleść istniejące implementacje, niektóre z nich są komercyjne
 ale zdarzają się także takie o otwartym kodzie źródłowym.
 Poniżej zamieszczono krótką charakterystykę wybranych technologii.
\end_layout

\begin_layout Subsection*
OpenMP (ang.
 Open Multi-Processing) 
\end_layout

\begin_layout Standard
Standard używany na skalę przemysłową, korzystający z modelu Threads i pamięci
 współdzielonej.
 Dostępne są implementację w językach C/C++ oraz Fortran.
 Pozwala na wielowątkowe obliczenia w których wiele wątków pracuje na tym
 samym zestawie danych.
 Pierwsza wersja standardu została opublikowana w roku 1997 dla języka Fortran
 
\begin_inset CommandInset citation
LatexCommand cite
key "65"

\end_inset

.
\end_layout

\begin_layout Subsection*
MPI (ang.
 Message Passing Interface)
\end_layout

\begin_layout Standard
Popularny standard szeroko stosowany w obliczeniach równoległych, jak również
 w przemyśle, powstał w roku 1994.
 Korzysta z modelu Message Passing i Distributed Memory.
 Najbardziej znane implementacje to OpenMPI i MPICH dla języków C oraz Fortran.
 Zapewnia komunikację przez sieć dla danych przetwarzanych na różnych fizycznych
 maszynach 
\begin_inset CommandInset citation
LatexCommand cite
key "64"

\end_inset

.
\end_layout

\begin_layout Subsection*
CUDA (ang.
 Compute Unified Device Architecture)
\end_layout

\begin_layout Standard
Jest to technologia opracowana w 2007 roku przez firmę NVIDIA, producenta
 kart graficznych.
 Wykorzystuje układy GPU a co za tym idzie architekturę SIMD.
 Pozwala wykonywać obliczenia równoległe.
 Dostarcza SDK oraz API pozwalające na pisanie aplikacji z wykorzystaniem
 języka C/C++ lub Fortran.
 Ma zastosowanie w przetwarzaniu video, biologii obliczeniowej i chemii,
 astrofizyce oraz różnego rodzaju symulacjach lub analizach 
\begin_inset CommandInset citation
LatexCommand cite
key "66"

\end_inset

.
\end_layout

\begin_layout Subsection*
OpenCL (ang.
 Open Computing Language)
\end_layout

\begin_layout Standard
Technologia o otwartym kodzie źródłowym w przeciwieństwie do CUDA, rozwijana
 przez grupę Khronos od 2009 roku.
 Wykorzystująca do obliczeń również procesory graficzne.
 Dodatkowo wspierająca obliczenia równoległe na zwykłych procesorach CPU.
 Podczas gdy CUDA wykorzystuje karty graficzne firmy NVIDIA, OpenCL wspiera
 również platformy AMD, Intel, ARM oraz wiele innych.
 Technologia jest oparta o język C++ 
\begin_inset CommandInset citation
LatexCommand cite
key "67"

\end_inset

.
\end_layout

\begin_layout Subsection*
Java Concurrency Framework 
\end_layout

\begin_layout Standard
Większość współczesnych obiektowych języków programowania wspiera pojęcie
 współbieżności poprzez wątki, które operują na pamięci współdzielonej.
 Nie inaczej jest z Javą, w której od wersji 5 wprowadzono wiele usprawnień
 do wsparcia wielowątkowości m.in.
 relację happens-before, która wymusza, że jeden dostęp do pamięci musi
 nastąpić przed innymi.
 Poza wieloma mechanizmami wspomagającymi różne poziomy synchronizacji wprowadzo
no również wysokopoziomowe API, wiele kolekcji oraz typów danych z wbudowanymi
 mechanizmami wspierającymi współbieżność i ułatwiającymi programiście implement
owanie obliczeń równoległych 
\begin_inset CommandInset citation
LatexCommand cite
key "71"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
Poza frameworkami wymienionymi powyżej, których użycie oraz przygotowanie
 końcowego rozwiązania często wymaga dużo czasu, powstało również kilka
 gotowych systemów oferujących sprawdzone implementacje niektórych problemów
 i będące punktem wyjścia dla bardziej skomplikowanych rozwiązań.
 
\end_layout

\begin_layout Subsection*
Apache Hadoop
\end_layout

\begin_layout Standard
Jest to framework open-source napisany w Javie i wspierający obliczenia
 równoległe prowadzone na dużych ilościach danych w środowisku rozproszonym,
 takim jak klastry komputerowe.
 Pierwsza wersja została opublikowana w 2005 roku.
 Jego dwoma głównymi komponentami są HDFS (Hadoop Distributed File System)
 wykorzystujący technologię HBase i służący do przechowywania danych oraz
 MapReduce służący do przetwarzania danych.
 Kolejnym istotnym komponentem jest YARN pomagający zarządzać zasobami dostępnym
i w klastrze oraz wykorzystywany do harmonogramowania zadań.
 Zamierzeniem twórców było stworzenie narzędzia dobrze skalowalnego oraz
 zapewniającego wysoką dostępność poprzez wykrywanie stanu urządzeń pracujących
 w klastrze 
\begin_inset CommandInset citation
LatexCommand cite
key "74"

\end_inset

.
\end_layout

\begin_layout Subsection*
HTCondor
\end_layout

\begin_layout Standard
Jest systemem służącym do zarządzania zasobami oraz kolejkowaniem zadań
 w architekturach rozproszonych.
 Jest to projekt Open-source rozwijany przez Uniwersystet Wisconsin-Madison.
 Powstał w latach 80-tych.
 Może być uruchamiany na wielu platformach takich jak Windows czy Linux.
 Dostarcza mechanizmy zabezpieczeń takie jak autentykacja, autoryzacja i
 szyfrowanie danych, jak również mechanizmy do wspomagania administrowania
 systemem.
 Może być użyty do rozłożenia obciążenia na komputerach pracujących w klastrze,
 jak również do wykorzystania wolnych zasobów podłączonych do niego komputerów
 zwykłych użytkowników w celu wykonywania obliczeń dużej skali wykorzystując
 czas gdy komputery są nieobciążone.
 Wspiera równoległe wykonywanie zadań napisanych w standardzie MPI.
 Może również zarządzać zasobami znajdującymi się w chmurze obliczeniowej
 lub gridzie 
\begin_inset CommandInset citation
LatexCommand cite
key "73"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
Wymienione wyżej narzędzia implementują różne modele programowania równoległego.
 Warto również wspomnieć o takich architekturach jak systemy gridowe lub
 klastry komputerowe, które są polem do testowania wspomnianych technologii
 oraz w dużym stopniu przyczyniły się do ich rozwoju.
 
\end_layout

\begin_layout Subsection*
Systemy klastrowe
\end_layout

\begin_layout Standard
Klaster komputerowy jest zbiorem wielu komputerów połączonych zazwyczaj
 w sieci LAN i mających na celu rozwiązanie złożonego problemu obliczeniowego
 oraz współpracujących ze sobą.
 Zazwyczaj są używane do zwiększenia wydajności oraz dostępności konkretnych
 usług.
 W porównaniu do gridów komputery pracujące w klastrze mają podobną architekturę
 oraz zazwyczaj zajmują się wykonywaniem podobnych, skoordynowanych zadań.
 Mogą posiadać dostęp poprzez sieć do magazynu danych, który można traktować
 jako pamięć współdzieloną.
 W typowym wykorzystaniu klastra istnieje dodatkowo maszyna klienta, która
 dystrybuuje zadania do klastra i zbiera wyniki.
\end_layout

\begin_layout Subsection*
Systemy gridowe
\end_layout

\begin_layout Standard
Systemy które integrują heterogeniczne zasoby będące pod kontrolą różnych
 domen i połączone siecią komputerową WAN.
 Zapewniają narzędzia do zarządzania zasobami, uwierzytelniania oraz autoryzacji
 w celu rozwiązywania problemów dużej skali.
 Gridy są rozszerzeniem idei klastrów.
 Mogą zapewniać takie usługi jak globalny magazyn danych, aplikacje sieciowe,
 Software as a Service czyli pojęcia znane z chmur obliczeniowych 
\begin_inset CommandInset citation
LatexCommand cite
key "68,75"

\end_inset

.
\end_layout

\begin_layout Section
Scala i Akka
\end_layout

\begin_layout Standard
Technologiom Scala i Akka został poświęcony osobny rozdział, ze względu
 na wykorzystanie ich w części praktyczej niniejszej pracy.
 Scala posiada wsparcie dla dwóch modeli programowania równoległego takich
 jak STM oraz Actor Model, który został wykorzystany dzięki użyciu frameworka
 Akka.
 Z kolei rozszerzenia Akka, takie jak Akka Cluster wspierają użycie tego
 frameworka w klastrach komputerowych.
\end_layout

\begin_layout Subsection*
Scala 
\begin_inset Note Note
status open

\begin_layout Plain Layout
start
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Scala jest językiem funkcyjnym rozwijanym od 2001 roku przez firmę Typesafe,
 której współtwórcą jest Martin Odersky na codzień pracujący na Uniwersytecie
 w Lozannie.
 Głównym aspektem przemawiającym na korzyść tego języka jest to, że do jego
 działania wystarczy maszyna wirtualna Javy.
 Jest to język obiektowy podobnie jak Java, ale łączy również zalety języków
 funkcyjnych, które w ostatnim czasie stają się coraz bardziej popularne.
 Zamiarem twórców było stworzenie języka eleganckiego oraz zwięzłego syntaktyczn
ie.
 Mimo, że Scala jest językiem dynamicznie typowanym zapewnia tzw.
 type safety 
\begin_inset CommandInset citation
LatexCommand cite
key "42"

\end_inset

.
 Wprowadza również wiele innowacji oraz ciekawych rozwiązań do konstrukcji
 języka jak np.
 case classes, currying, zagnieżdżanie funkcji, DSL, słowo kluczowe lazy
 lub trait, konsktrukcja podobna do interfejsu z języka Java ale mogąca
 posiadać częściową implementację.
 Scala preferuje obiekty niemutowalne.
 Obsługuje również funkcje wyższego rzędu oraz pozwala zwięźle definiować
 funkcje anonimowe, kładzie również duży nacisk na skalowalność.
 Dodatkową zaletą tego języka jest to, iż jest on w pełni kompatybilny z
 językiem Java, co oznacza, że możemy w nim używać bibliotek lub frameworków
 napisanych w Javie bez żadnych dodatkowych deklaracji.
 Ostatecznie program napisany w Scali jest kompilowany do kodu bajtowego
 Javy 
\begin_inset CommandInset citation
LatexCommand cite
key "27,28,30,8"

\end_inset

.
 
\end_layout

\begin_layout Subsection*
Akka
\end_layout

\begin_layout Standard
Jednym z kluczowych frameworków wykorzystanych w niniejszej pracy jest Akka.
 Akka jest projektem Open-source na licencji Apache 2 powstałym w roku 2009.
 Posiada wersję przeznaczoną dla języka Java, jak również dla języka Scala.
 Stał się częścią implemetacji języka Scala od wersji 2.10.
 Projekt Akka pomimo stosunkowo niedługiej obecności na rynku jest w pełni
 gotowy do zastosowań produkcyjnych.
 Cechuje się obecnością wielu interesujących z punktu widzenia niniejszej
 pracy rozszerzeń, które zostały opisane w jednym z następnych podrodziałów,
 wyczerpującej dokumentacji oraz dużej i aktywnej społeczności rozwijającej
 ten produkt, a także wsparciem komercyjnych firm.
 Akka używa modelu aktorowego aby zwiększyć poziom abstrakcji i oddzielić
 logikę biznesową od niskopoziomowego zarządzania wątkami oraz operacjami
 I/O 
\begin_inset CommandInset citation
LatexCommand cite
key "29,31"

\end_inset

.
\end_layout

\begin_layout Standard
Podstawowym bytem w technologii Akka są aktorzy.
 Aktor zapewnia wysokopoziomową abstrakcję dla lepszej współbieżności oraz
 zrównoleglenia operacji.
 Jest on lekkim, wydajnym oraz sterowanym zdarzeniami procesem, który komunikuje
 się z innymi aktorami za pomocą asynchronicznych i niemutowalnych wiadomości
 przechowywanych w skrzynkach odbiorczych, które posiada każdy aktor.
 Aktor enkapsuluje pewien stan i zachowania, które realizują określone zadania
 
\begin_inset CommandInset citation
LatexCommand cite
key "31"

\end_inset

.
\end_layout

\begin_layout Standard
Każdy aktor w systemie może być identyfikowany na kilka różnych sposobów,
 głównym z nich jest unikalny adres aktora dzięki któremu może zostać znaleziony
 przez innych aktorów np.
 w celu wysłania wiadomości.
 Aktorzy działają w obrębie systemu zwanego Actor System opisanego w pozycji
 
\begin_inset CommandInset citation
LatexCommand cite
key "49"

\end_inset

.
 System aktorowy można traktować jako pewną strukturę z zaalokowaną pulą
 wątków, stworzoną w ramach jednej logicznej aplikacji.
 Konfiguracją puli wątków zajmuje się Akka.
 Pewne ustawienia mogą być zmienione programatycznie lub w pliku 
\shape italic
application.conf
\shape default
, który jest głównym plikiem konfiguracyjnym systemu aktorowego.
 System aktorowy zarządza dostępnymi zasobami i może mieć uruchomione wiele
 aktorów, instancja każdego z aktorów zajmuje zaledwie 300 bajtów pamięci.
\end_layout

\begin_layout Standard
Akka Framework dostarcza wszystkich zalet programowania reaktywnego 
\begin_inset CommandInset citation
LatexCommand cite
key "43"

\end_inset

 oraz zapewnia między innymi:
\end_layout

\begin_layout Itemize
współbieżność, dzięki zaadaptowaniu modelu aktorowego, programista może
 zatem skupić się na logice biznesowej zamiast zajmować się problemami współbież
ności,
\end_layout

\begin_layout Itemize
skalowalność, asynchroniczna komunikacja pomiędzy aktorami dobrze skaluje
 się w systemach multiprocesorowych,
\end_layout

\begin_layout Itemize
odporność na błędy, framework Akka zapożyczył podejście z języka Erlang,
 co pozwoliło wykorzystać model 
\shape italic
let it crash 
\shape default

\begin_inset CommandInset citation
LatexCommand cite
key "54"

\end_inset

 (zwany też 
\shape italic
fail fast)
\shape default
 do zapewnienia niezawodnego działania systemu i skrócenia jego niedostępności,
\end_layout

\begin_layout Itemize
architekturę sterowaną zdarzeniami,
\end_layout

\begin_layout Itemize
transakcyjność,
\end_layout

\begin_layout Itemize
ujednolicony model programowania dla potrzeb wielowątkowości oraz obliczeń
 rozproszonych,
\end_layout

\begin_layout Itemize
Akka wspiera zarówno API języka Java jak i języka Scala 
\begin_inset CommandInset citation
LatexCommand cite
key "29"

\end_inset

.
\end_layout

\begin_layout Standard
Zastosowania projektu Akka są bardzo szerokie, można je odnaleść w następujących
 dziedzinach:
\end_layout

\begin_layout Itemize
analiza danych,
\end_layout

\begin_layout Itemize
bankowość inwestycyjna,
\end_layout

\begin_layout Itemize
eCommerce,
\end_layout

\begin_layout Itemize
symulacje,
\end_layout

\begin_layout Itemize
media społecznościowe,
\end_layout

\begin_layout Itemize
batch processing,
\end_layout

\begin_layout Itemize
transaction processing (online gaming, social media, telecom, finanse, zakłady),
\end_layout

\begin_layout Itemize
aplikacje real-time,
\end_layout

\begin_layout Itemize
serwisy REST, SOAP, message hub.
\end_layout

\begin_layout Standard
Systemy w których potrzebujemy uzyskać wysoką przepustowość oraz małe opóźnienia
 są dobrym kandydatem do wykorzystania frameworka Akka 
\begin_inset CommandInset citation
LatexCommand cite
key "31"

\end_inset

.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Subsubsection*
Akka Cluster
\end_layout

\begin_layout Standard
Jest to rozszerzenie projektu Akka pozwalające zaimplementować komunikację
 pomiędzy urządzeniami działającymi w obrębie klastra.
 Zapewnia ono pewien poziom abstrakcji dla protokołu TCP/IP 
\begin_inset CommandInset citation
LatexCommand cite
key "51"

\end_inset

.
\end_layout

\begin_layout Standard
Dostarcza również odporny na awarię oraz zdecentralizowany serwis członkostwa
 (ang.
 membership service) oparty na protokole Gossip 
\begin_inset CommandInset citation
LatexCommand cite
key "33"

\end_inset

 oraz automatycznej detekcji niedziałających węzłów (ang.
 failure detector).
 
\end_layout

\begin_layout Standard
Pojęcia:
\end_layout

\begin_layout Itemize
węzeł (ang.
 node) - logiczny członek klastra, może istnieć wiele węzłów na jednej fizycznej
 maszynie, identyfikowany krotką: nazwa_hosta:port:uid,
\end_layout

\begin_layout Itemize
klaster (ang.
 cluster) - grupa węzłów zarejestrowana w serwisie członkostwa, 
\end_layout

\begin_layout Itemize
lider (ang.
 leader) - węzeł odpowiedzialny za kluczowe akcje pozwalające zachować odpowiedn
i stan klastra w przypadku dołączania nowych lub awarii istniejących węzłów
 
\begin_inset CommandInset citation
LatexCommand cite
key "31"

\end_inset

.
\end_layout

\begin_layout Standard
Lider jest tylko rolą jaką posiada dany węzeł, każdy węzeł może zostać liderem
 oraz każdy węzeł jest w stanie w sposób deterministyczny wyznaczyć lidera.
 Węzły mogą też posiadać inne role, które mogą się przydać np.
 w ograniczeniu zasięgu komunikacji.
 
\end_layout

\begin_layout Standard
Protokół Gossip wspomniany powyżej pozwala rozpropagować stan klastra do
 wszystkich jego węzłów tak, aby każdy węzeł miał takie same informację
 o pozostałych członkach klastra.
 Protokół ten pomaga uzyskać zbieżność stanu klastra we wszystkich jego
 węzłach w skończonym czasie.
 
\end_layout

\begin_layout Standard
Czlonkostwo w klastrze jest rozpoczynane komendą 
\shape italic
join
\shape default
 wysyłaną do jednego z aktywnych członków klastra, gdy każdy węzeł klastra
 otrzyma informację o dołączającym węźle dzięki protokołowi Gossip, taki
 węzeł może zostać uznany za osiągalny.
 Może on jednak utracić ten stan gdy np.
 wystąpią jakieś problemy z siecią.
 Stan nieosiągalny może trwać jedynie określony czas po upływie którego
 jeśli węzeł nie powróci do pełnej sprawności utraci on status członka klastra.
 Każdy węzeł poza nazwą hosta oraz portem jest identyfikowany dodatkowo
 unikalnym identyfikatorem, tzw.
 uid, co pozwala na uruchomienie kilku węzłów klastra na jednej fizycznej
 maszynie.
 Jeżeli członek klastra ulegnie awarii lub opuści klaster na własne życzenie,
 nie może on ponownie dołączyć do klastra dopóki system aktorowy uruchomiony
 na nim nie zostanie zrestartowany, co pozwoli na wygenerowanie nowego uid.
 Każdy węzeł może zmienić swój stan członkostwa lub może on zostać zmieniony
 dzięki automatycznej detekcji niedziałających węzłów.
 Ustawienia detekcji niedziałających węzłów oraz protokołu Gossip są konfigurowa
lne, tzn.
 że można np.
 ustalić czas po którym węzeł zostanie uznany za nieosiągalny.
 Zdarzenia związane ze zmianą stanu węzłów klastra mogą być subskrybowane
 przez istniejących członków, co ułatwia implementację monitoringu stanu
 klastra.
 Więcej szczegółów na temat idei członkostwa w klastrze oraz dostępnych
 stanów węzłów można znaleść w pozycjach 
\begin_inset CommandInset citation
LatexCommand cite
key "31,56"

\end_inset

.
 
\end_layout

\begin_layout Standard
Kolejną ciekawą opcją w rozszerzeniu Akka Cluster jest wykorzystanie bibliotek
 Sigar 
\begin_inset CommandInset citation
LatexCommand cite
key "57"

\end_inset

 oraz integracja z nimi.
 Pozwalają one na dostęp do informacji systemowych takich jak zużycie CPU,
 wykorzystanie pamięci RAM, stan sieci.
 Mogą zostać wykorzystane do implementacji load-balancigu lub monitorowania
 obciążenia urządzeń klastra 
\begin_inset CommandInset citation
LatexCommand cite
key "34,32"

\end_inset

.
\end_layout

\begin_layout Subsection*
Cluster Singleton
\end_layout

\begin_layout Standard
Cluster Singleton jest rozszerzeniem projektu Akka zapewniającym jedną instancję
 aktora danego typu w obrębie klastra lub w obrębie węzłów z wybraną rolą.
 Może zostać wykorzystane do zaimplementowania modelu Master/Slave opisanego
 w jednym z poprzednich podrozdziałów.
 Rozszerzenie to dostarcza implementacji menedżera, który pozwala zarządzać
 instancjonowaniem aktora typu singleton.
 Dostęp do działającej instancji jest możliwy z każdego urządzenia działającego
 w klastrze i odbywa się poprzez aktora pośrednika, tzw.
 proxy 
\begin_inset CommandInset citation
LatexCommand cite
key "14"

\end_inset

.
\end_layout

\begin_layout Subsection*
Distributed Publish Subscribe in Cluster
\end_layout

\begin_layout Standard
Rozszerzenie projektu Akka, które umożliwia komunikację między aktorami
 bez posiadania informacji na których konkretnie urządzeniach poszczególni
 aktorzy są uruchomieni, czyli lokacja aktora jest transparentna z punktu
 widzenia komunikacji.
 Dostarcza ono aktora pełniącego rolę mediatora, który zarządza rejestracją
 innych aktorów do konkretnych kanałów komunikacji którymi są zainteresowani.
 Zachowanie to można porównać z subskrypcją RSS 
\begin_inset CommandInset citation
LatexCommand cite
key "55"

\end_inset

.
 Wiadomość opublikowana w danym kanale powinna zostać dostarczona do wszystkich
 aktorów, którzy zostali w nim poprzednio zarejestrowani.
 Rozszerzenie to pozwala również wysłać wiadomość do jednego lub większej
 ilości aktorów pasujących do określonego wzorca 
\begin_inset CommandInset citation
LatexCommand cite
key "47"

\end_inset

.
\end_layout

\end_body
\end_document
